@using Microsoft.AspNetCore.Components.Forms

@namespace Soenneker.Quark
@inherits Element

<CascadingValue Value="@this" IsFixed>
    <CascadingValue Value="@EditContext">
        @ChildContent
    </CascadingValue>
</CascadingValue>

@code {
    private readonly List<IValidation> _validations = [];

    /// <summary>
    /// Gets or sets the validation mode.
    /// </summary>
    [Parameter]
    public ValidationMode Mode { get; set; } = ValidationMode.Auto;

    /// <summary>
    /// Gets or sets whether to validate on component load.
    /// </summary>
    [Parameter]
    public bool ValidateOnLoad { get; set; }

    /// <summary>
    /// Gets or sets the edit context for validation.
    /// </summary>
    [Parameter]
    public EditContext? EditContext { get; set; }

    /// <summary>
    /// Gets or sets the model to validate.
    /// </summary>
    [Parameter]
    public object? Model { get; set; }

    /// <summary>
    /// Gets or sets the callback invoked when the model changes.
    /// </summary>
    [Parameter]
    public EventCallback<object> ModelChanged { get; set; }

    /// <summary>
    /// Gets or sets the error message to display when fields are missing.
    /// </summary>
    [Parameter]
    public string? MissingFieldsErrorMessage { get; set; }

    /// <summary>
    /// Gets or sets the handler type for validation.
    /// </summary>
    [Parameter]
    public Type? HandlerType { get; set; }

    /// <summary>
    /// Gets or sets the callback invoked when all validations pass.
    /// </summary>
    [Parameter]
    public EventCallback ValidatedAll { get; set; }

    /// <summary>
    /// Gets or sets the callback invoked when the validation status changes.
    /// </summary>
    [Parameter]
    public EventCallback<ValidationsStatusChangedEventArgs> StatusChanged { get; set; }

    internal event Action<ValidationsStatusChangedEventArgs>? _statusChanged;

    protected override void OnParametersSet()
    {
        // Check if EditContext was explicitly set by checking if it's not null and different from what we would create from Model
        var editContextExplicitlySet = EditContext is not null && (Model is null || !ReferenceEquals(Model, EditContext.Model));
        
        if (editContextExplicitlySet && Model is not null)
            throw new InvalidOperationException("Validations requires a Model parameter, or an EditContext parameter, but not both.");

        if (Model is not null && !ReferenceEquals(Model, EditContext?.Model))
            EditContext = new EditContext(Model);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && ValidateOnLoad && Mode == ValidationMode.Auto)
        {
            await Validate();
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    /// <summary>
    /// Validates all registered validations.
    /// </summary>
    /// <returns>True if all validations pass; otherwise, false.</returns>
    public async Task<bool> Validate()
    {
        var result = await TryValidate();

        if (result)
        {
            RaiseStatusChanged(ValidationStatus.Success, null, null);
            await InvokeAsync(() => ValidatedAll.InvokeAsync());
        }
        else if (HasFailedValidations)
        {
            RaiseStatusChanged(ValidationStatus.Error, FailedValidations, null);
        }

        return result;
    }

    /// <summary>
    /// Clears all validations.
    /// </summary>
    /// <returns>A task that represents the asynchronous operation.</returns>
    public Task ClearAll()
    {
        ClearingAll?.Invoke();
        RaiseStatusChanged(ValidationStatus.None, null, null);
        return Task.CompletedTask;
    }

    private async Task<bool> TryValidate()
    {
        var validated = true;

        foreach (var v in _validations)
        {
            if (await v.ValidateAsync() == ValidationStatus.Error)
                validated = false;
        }

        return validated;
    }

    /// <summary>
    /// Notifies that a validation has been initialized.
    /// </summary>
    /// <param name="validation">The validation that was initialized.</param>
    public void NotifyValidationInitialized(IValidation validation)
    {
        if (!_validations.Contains(validation))
            _validations.Add(validation);
    }

    /// <summary>
    /// Notifies that a validation has been removed.
    /// </summary>
    /// <param name="validation">The validation that was removed.</param>
    public void NotifyValidationRemoved(IValidation validation)
    {
        if (_validations.Contains(validation))
            _validations.Remove(validation);
    }

    /// <summary>
    /// Notifies that a validation's status has changed.
    /// </summary>
    /// <param name="validation">The validation whose status changed.</param>
    public void NotifyValidationStatusChanged(IValidation validation)
    {
        if (Mode == ValidationMode.Manual)
            return;

        if (AllValidationsSuccessful)
        {
            RaiseStatusChanged(ValidationStatus.Success, null, validation);
            ValidatedAll.InvokeAsync();
        }
        else if (HasFailedValidations)
        {
            RaiseStatusChanged(ValidationStatus.Error, FailedValidations, validation);
        }
        else
        {
            RaiseStatusChanged(ValidationStatus.None, null, validation);
        }
    }

    private void RaiseStatusChanged(ValidationStatus status, IReadOnlyCollection<string>? messages, IValidation? validation)
    {
        var args = new ValidationsStatusChangedEventArgs(status, messages, validation);
        _statusChanged?.Invoke(args);
        InvokeAsync(() => StatusChanged.InvokeAsync(args));
    }

    public bool AllValidationsSuccessful => _validations.All(x => x.Status == ValidationStatus.Success);
    public bool HasFailedValidations => _validations.Any(x => x.Status == ValidationStatus.Error);

    private IReadOnlyCollection<string> FailedValidations
    {
        get
        {
            var messages = new List<string>();
            var hasErrorWithoutMessages = false;

            foreach (var validation in _validations)
            {
                if (validation.Status != ValidationStatus.Error)
                    continue;

                if (validation.Messages is { } validationMessages && validationMessages.Any())
                {
                    messages.AddRange(validationMessages);
                }
                else
                {
                    hasErrorWithoutMessages = true;
                }
            }

            if (hasErrorWithoutMessages)
            {
                messages.Add(MissingFieldsErrorMessage ?? "One or more fields have an error.");
            }

            return messages;
        }
    }

    protected override Dictionary<string, object> BuildAttributes()
    {
        var attributes = base.BuildAttributes();

        BuildClassAttribute(attributes, (ref cls) =>
        {
            AppendClass(ref cls, "q-validations");
        });

        return attributes;
    }

    public event Action? ClearingAll;
}
