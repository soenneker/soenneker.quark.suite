@using Soenneker.Blazor.Extensions.EventCallback

@namespace Soenneker.Quark
@inherits Soenneker.Quark.Element
@implements Soenneker.Quark.IValidationInput
@implements IMemoEdit

<textarea @attributes="BuildAttributes()">@Value</textarea>

@code {
    public override string? ThemeKey { get; set; } = "MemoEdit";

	[Parameter]
	public string? Value { get; set; }

	[Parameter]
	public string? Placeholder { get; set; }

	[Parameter]
	public bool Disabled { get; set; }

	[Parameter]
	public bool ReadOnly { get; set; }

	[Parameter]
	public bool Required { get; set; }

	[Parameter]
	public int Rows { get; set; } = 3;

	[Parameter]
	public int MaxLength { get; set; }

	[Parameter]
	public int MinLength { get; set; }

	[Parameter]
	public string? Pattern { get; set; }

	[Parameter]
	public bool AutoResize { get; set; }

	[Parameter]
	public CssValue<SizeBuilder>? Size { get; set; } = Quark.Size.Default;

	[Parameter]
	public EventCallback<string?> ValueChanged { get; set; }

	[Parameter]
	public EventCallback<ChangeEventArgs> OnChange { get; set; }

	[Parameter]
	public EventCallback<ChangeEventArgs> OnInput { get; set; }

	[CascadingParameter]
	public Validation? ParentValidation { get; set; }

	public object? ValidationValue => Value;

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender && ParentValidation is not null)
		{
			await ParentValidation.InitializeInput(this);
			ParentValidation.ValidationStatusChanged += OnParentValidationStatusChanged;
		}

		await base.OnAfterRenderAsync(firstRender);
	}

	private void OnParentValidationStatusChanged(object? sender, ValidationStatusChangedEventArgs e)
	{
		InvokeAsync(StateHasChanged);
	}

	private bool ShouldShowInvalid()
	{
		if (ParentValidation is null || ParentValidation.Status != ValidationStatus.Error)
			return false;

		var showInvalidProp = ParentValidation.GetType().GetProperty("ShouldShowInvalid");
		var showInvalid = showInvalidProp?.GetValue(ParentValidation) as bool? ?? true;
		return showInvalid;
	}

	private bool ShouldShowValid()
	{
		return ParentValidation?.Status == ValidationStatus.Success;
	}

	private string? GetValidationClass()
	{
		if (ShouldShowInvalid())
			return "is-invalid";

		if (ShouldShowValid())
			return "is-valid";

		return null;
	}

	private string? GetColorClass()
    {
        string? token = null;
        var isTheme = BackgroundColor?.TryGetBootstrapThemeToken(out token) == true;

		if (isTheme && token is not null)
			return $"form-control-{token}";

		return null;
	}

	private string? GetSizeClass()
	{
		if (Size == Quark.Size.Default)
			return null;

		string? token = null;
		var isTheme = Size?.TryGetBootstrapThemeToken(out token) == true;
		if (isTheme && token is not null)
			return $"form-control-{token}";

		return Size?.ToString() != null ? $"form-control-{Size}" : null;
	}


	protected override Dictionary<string, object> BuildAttributes()
	{
		var attributes = base.BuildAttributes();

		BuildClassAttribute(attributes, (ref PooledStringBuilder cls) =>
		{
			AppendClass(ref cls, "form-control");
			
			var colorClass = GetColorClass();
			if (colorClass != null)
				AppendClass(ref cls, colorClass);
				
			var sizeClass = GetSizeClass();
			if (sizeClass != null)
				AppendClass(ref cls, sizeClass);
				
			var validationClass = GetValidationClass();
			if (validationClass != null)
				AppendClass(ref cls, validationClass);
		});

		if (Placeholder.HasContent())
			attributes["placeholder"] = Placeholder;

		if (Disabled)
			attributes["disabled"] = true;

		if (ReadOnly)
			attributes["readonly"] = true;

		if (Required)
			attributes["required"] = true;

		if (Rows > 0)
			attributes["rows"] = Rows;

		if (MaxLength > 0)
			attributes["maxlength"] = MaxLength;

		if (MinLength > 0)
			attributes["minlength"] = MinLength;

		if (Pattern.HasContent())
			attributes["pattern"] = Pattern;

		if (AutoResize)
			BuildStyleAttribute(attributes, (ref PooledStringBuilder sty) => AppendStyleDecl(ref sty, "resize: vertical; min-height: 60px;"));

		// Wire input/change events
		attributes["oninput"] = EventCallback.Factory.Create<ChangeEventArgs>(this, HandleInput);
		attributes["onchange"] = EventCallback.Factory.Create<ChangeEventArgs>(this, HandleChange);

		return attributes;
	}

	private async Task HandleInput(ChangeEventArgs e)
	{
		Value = e?.Value?.ToString() ?? string.Empty;
		await ValueChanged.InvokeIfHasDelegate(Value);

		if (OnInput.HasDelegate)
			await OnInput.InvokeIfHasDelegate(e);

		if (ParentValidation is not null)
		{
			ParentValidation.MarkTouched();
			await ParentValidation.NotifyInputChanged(Value ?? string.Empty);
		}
	}

	private async Task HandleChange(ChangeEventArgs e)
	{
		Value = e?.Value?.ToString() ?? string.Empty;
		await ValueChanged.InvokeIfHasDelegate(Value);
		await OnChange.InvokeIfHasDelegate(e);

		if (ParentValidation is not null)
		{
			ParentValidation.MarkTouched();
			await ParentValidation.NotifyInputChanged(Value ?? string.Empty);
		}
	}

	public override void Dispose()
	{
		base.Dispose();

		if (ParentValidation is not null)
			ParentValidation.ValidationStatusChanged -= OnParentValidationStatusChanged;
	}

}
