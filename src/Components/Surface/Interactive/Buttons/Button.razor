@using System.Runtime.CompilerServices
@using Soenneker.Quark.Components.Surface.Interactive.Buttons.Abstract

@namespace Soenneker.Quark
@inherits InteractiveSurfaceElement
@implements IButton
@inject NavigationManager Navigation

@if (Type == ButtonType.Link)
{
    <Anchor To="To" Attributes="BuildAttributes()">
        @ChildContent
    </Anchor>
}
else
{
    <button @onclick="HandleClick" @attributes="BuildAttributes()">
        @if (Loading)
        {
            <span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
        }
        @if (LoadingTemplate is not null && Loading)
        {
            @LoadingTemplate
        }
        else
        {
            @ChildContent
        }
    </button>
}

@code {
    /// <summary>
    /// Gets or sets the size of the button.
    /// </summary>
    [Parameter]
    public CssValue<SizeBuilder>? Size { get; set; }

    /// <summary>
    /// Gets or sets whether the button is disabled.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }

    /// <summary>
    /// Gets or sets whether the button should use outline styling.
    /// </summary>
    [Parameter]
    public bool Outline { get; set; }

    /// <summary>
    /// Gets or sets whether the button should span the full width of its container.
    /// </summary>
    [Parameter]
    public bool Block { get; set; }

    /// <summary>
    /// Gets or sets whether the button is in a loading state.
    /// </summary>
    [Parameter]
    public bool Loading { get; set; }

    /// <summary>
    /// Gets or sets the type of the button (button, submit, reset, or link).
    /// </summary>
    [Parameter]
    public ButtonType Type { get; set; } = ButtonType.Button;

    /// <summary>
    /// Gets or sets the template to display when the button is in a loading state.
    /// </summary>
    [Parameter]
    public RenderFragment? LoadingTemplate { get; set; }

    /// <summary>
    /// Gets or sets the value attribute of the button.
    /// </summary>
    [Parameter]
    public string? Value { get; set; }

    /// <summary>
    /// Gets or sets the form ID that this button is associated with.
    /// </summary>
    [Parameter]
    public string? Form { get; set; }

    /// <summary>
    /// Gets or sets whether the button should automatically receive focus when the page loads.
    /// </summary>
    [Parameter]
    public bool AutoFocus { get; set; }

    /// <summary>
    /// Gets or sets the navigation target URL when the button type is Link.
    /// </summary>
    [Parameter]
    public string? To { get; set; }

    /// <summary>
    /// Gets or sets the name attribute of the button.
    /// </summary>
    [Parameter]
    public string? Name { get; set; }

    /// <summary>
    /// Gets or sets the ID of the collapse element to toggle when clicked.
    /// </summary>
    [Parameter]
    public string? CollapseTarget { get; set; }

    /// <summary>
    /// Gets or sets the reference to the collapse component to toggle when clicked.
    /// </summary>
    [Parameter]
    public Collapse? CollapseTargetRef { get; set; }

    /// <summary>
    /// Gets or sets whether the button should render as a close button.
    /// </summary>
    [Parameter]
    public bool Close { get; set; }

    /// <summary>
    /// Gets or sets whether the button should render without Bootstrap button styling.
    /// </summary>
    [Parameter]
    public bool Unstyled { get; set; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private string? GetSizeClass()
    {
        if (Size == Quark.Size.Default)
            return null;

        string? token = null;
        var isTheme = Size?.TryGetBootstrapThemeToken(out token) == true;

        if (isTheme && token is not null)
            return $"btn-{token}";

        // SizeBuilder now generates clean tokens like "lg", "sm" without prefix
        var sizeValue = Size?.ToString();
        return sizeValue.HasContent() ? $"btn-{sizeValue}" : null;
    }

    /// <summary>
    /// Builds the attributes dictionary for the button component.
    /// </summary>
    /// <returns>A dictionary of HTML attributes.</returns>
    protected override Dictionary<string, object> BuildAttributes()
    {
        var attributes = base.BuildAttributes();

        // Determine element kind
        var isLink = Type == ButtonType.Link || To.HasContent();

        // Figure out disabled state (treat presence of "disabled" attribute as true)
        var isDisabled = Disabled || Loading || attributes.ContainsKey("disabled");

        // Links that are disabled/loading should not be in tab order (unless user explicitly set TabIndex)
        if (isLink && isDisabled && !attributes.ContainsKey("tabindex"))
            attributes["tabindex"] = -1;

        // Add Bootstrap button classes unless explicitly unstyled
        BuildClassAttribute(attributes, (ref PooledStringBuilder cls) =>
        {
            AppendClass(ref cls, "q-button");
            if (Close)
            {
                AppendClass(ref cls, "btn-close");
            }
            else if (!Unstyled)
            {
                AppendClass(ref cls, "btn");
            }

            if (!Unstyled)
            {
                var sizeClass = GetSizeClass();
                if (sizeClass is not null)
                    AppendClass(ref cls, sizeClass);

                if (Block)
                    AppendClass(ref cls, "btn-block");
            }

            if (isLink && isDisabled)
                AppendClass(ref cls, "disabled");
        });

        // Common ARIA for loading/disabled
        if (Loading)
            attributes["aria-busy"] = "true";

        // Only set type on real <button>
        if (!isLink)
            attributes["type"] = Type.Value;

        // Real disabled vs. aria-disabled
        if (isLink)
        {
            // Anchor can't be truly disabled; use ARIA
            if (isDisabled)
            {
                attributes["aria-disabled"] = "true";
                // role is already a good idea for link-as-button
                attributes["role"] = "button";
            }
            else
                attributes.TryAdd("role", "button");
        }
        else
        {
            if (isDisabled)
                attributes["disabled"] = true;
        }

        // Standard button/submit metadata
        if (Value.HasContent()) attributes["value"] = Value!;
        if (Name.HasContent()) attributes["name"] = Name!;
        if (Form.HasContent()) attributes["form"] = Form!;
        if (AutoFocus) attributes["autofocus"] = true;

        // Bootstrap collapse auto-wiring if requested
        var targetId = CollapseTargetRef?.CollapseId ?? CollapseTarget;
        if (targetId.HasContent())
        {
            attributes["data-bs-toggle"] = "collapse";
            var selector = targetId!.StartsWith("#") ? targetId : $"#{targetId}";
            attributes["data-bs-target"] = selector;
            attributes["aria-controls"] = selector.StartsWith("#") ? selector.Substring(1) : selector;
        }

        // If this is acting as a link, we already render <Anchor>; nothing special beyond attrs.
        return attributes;
    }

    /// <summary>
    /// Handles the click event for the button.
    /// </summary>
    /// <param name="args">The mouse event arguments.</param>
    protected override async Task HandleClick(MouseEventArgs args)
    {
        // Respect disabled state at runtime, same semantics as in BuildAttributes
        var isDisabled = Disabled || Loading || (Attributes is not null && Attributes.ContainsKey("disabled"));
        if (isDisabled)
            return;

        // Programmatic navigation if To is set (and not a hash)
        if (To.HasContent() && !To!.StartsWith("#"))
            Navigation.NavigateTo(To!);

        await base.HandleClick(args);
    }

    /// <summary>
    /// Applies background color styling to the button.
    /// </summary>
    /// <param name="sty">The style string builder.</param>
    /// <param name="cls">The class string builder.</param>
    protected override void ApplyBackgroundColor(ref PooledStringBuilder sty, ref PooledStringBuilder cls)
    {
        if (BackgroundColor is not null && !BackgroundColor.Value.IsEmpty && !Close)
        {
            var v = BackgroundColor.Value.ToString().Trim();
            var isColorTheme = BackgroundColor.Value.TryGetBootstrapThemeToken(out var colorToken);

            if (isColorTheme && colorToken is not null)
            {
                // Bootstrap theme token (e.g., "primary", "secondary")
                var prefix = Outline ? "btn-outline-" : "btn-";
                AppendClass(ref cls, $"{prefix}{colorToken}");
            }
            else if (BackgroundColor.Value.IsCssClass)
            {
                if (v.StartsWith("btn-", StringComparison.Ordinal))
                    AppendClass(ref cls, v);
                else
                {
                    var prefix = Outline ? "btn-outline-" : "btn-";
                    AppendClass(ref cls, $"{prefix}{v}");
                }
            }
            else
            {
                // Build style efficiently - BackgroundColor already handles background-color
                AppendStyleDecl(ref sty, $"border-color:{v}");
            }
        }
    }

}