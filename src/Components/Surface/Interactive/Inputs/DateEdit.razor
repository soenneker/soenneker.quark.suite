@using System.Linq.Expressions
@using Soenneker.Blazor.Extensions.EventCallback

@namespace Soenneker.Quark
@inherits InputSurfaceElement
@implements IDateEdit

<div class="q-date-edit">
    <Input Type="@GetInputModeString()"
           @attributes="BuildInputAttributes()" 
           OnInput="HandleInput"
           OnChange="HandleChange"
           ValidationValueSelector="@(() => (object?)Date ?? (object?)DateOnly)" />
</div>

@code {

	/// <summary>
	/// Gets or sets the date value.
	/// </summary>
	[Parameter]
	public DateTime? Date { get; set; }

	/// <summary>
	/// Gets or sets the expression that identifies the bound date value.
	/// </summary>
	[Parameter]
	public Expression<Func<DateTime?>>? DateExpression { get; set; }

	/// <summary>
	/// Gets or sets the date-only value.
	/// </summary>
	[Parameter]
	public DateOnly? DateOnly { get; set; }

	/// <summary>
	/// Gets or sets the expression that identifies the bound date-only value.
	/// </summary>
	[Parameter]
	public Expression<Func<DateOnly?>>? DateOnlyExpression { get; set; }

	/// <summary>
	/// Gets or sets the minimum date value.
	/// </summary>
	[Parameter]
	public DateTime Min { get; set; }

	/// <summary>
	/// Gets or sets the maximum date value.
	/// </summary>
	[Parameter]
	public DateTime Max { get; set; }

	/// <summary>
	/// Gets or sets the minimum date-only value.
	/// </summary>
	[Parameter]
	public DateOnly MinDateOnly { get; set; }

	/// <summary>
	/// Gets or sets the maximum date-only value.
	/// </summary>
	[Parameter]
	public DateOnly MaxDateOnly { get; set; }

	/// <summary>
	/// Gets or sets the step value for date increments.
	/// </summary>
	[Parameter]
	public int Step { get; set; } = 1;

	/// <summary>
	/// Gets or sets the input mode for the date picker.
	/// </summary>
	[Parameter]
	public DateInputMode InputMode { get; set; } = DateInputMode.Date;

	/// <summary>
	/// Gets or sets the callback invoked when the date changes.
	/// </summary>
	[Parameter]
	public EventCallback<DateTime?> DateChanged { get; set; }

	/// <summary>
	/// Gets or sets the callback invoked when the date-only value changes.
	/// </summary>
	[Parameter]
	public EventCallback<DateOnly?> DateOnlyChanged { get; set; }

	/// <summary>
	/// Gets or sets the size of the input.
	/// </summary>
	[Parameter]
	public CssValue<SizeBuilder>? Size { get; set; } = Quark.Size.Default;

	/// <summary>
	/// Gets or sets whether the input should be displayed as plain text.
	/// </summary>
	[Parameter]
	public bool PlainText { get; set; }

	/// <summary>
	/// Gets or sets whether the label should float.
	/// </summary>
	[Parameter]
	public bool FloatingLabel { get; set; }

	/// <summary>
	/// Gets or sets the label text.
	/// </summary>
	[Parameter]
	public string? Label { get; set; }

	/// <summary>
	/// Gets or sets the callback invoked when the input changes.
	/// </summary>
	[Parameter]
	public EventCallback<ChangeEventArgs> OnChange { get; set; }

	/// <summary>
	/// Gets or sets the callback invoked when the input value changes.
	/// </summary>
	[Parameter]
	public EventCallback<ChangeEventArgs> OnInput { get; set; }

	[CascadingParameter]
	public Validation? ParentValidation { get; set; }

	/// <summary>
	/// Gets the value used for validation.
	/// </summary>
	public object? ValidationValue => Date ?? (object?)DateOnly;

	public string? GetValidationClass()
	{
		if (ParentValidation?.Status == ValidationStatus.Error)
			return "is-invalid";

		if (ParentValidation?.Status == ValidationStatus.Success)
			return "is-valid";

		return null;
	}

	public string? GetColorClass()
	{
		if (BackgroundColor is not null && !BackgroundColor.Value.IsEmpty)
		{
			string? token = null;
			var isTheme = BackgroundColor.Value.TryGetBootstrapThemeToken(out token);

			if (isTheme && token is not null)
			{
				// Bootstrap theme token (e.g., "primary", "secondary")
				return $"form-control-{token}";
			}

			var v = BackgroundColor.Value.ToString().Trim();

			if (BackgroundColor.Value.IsCssClass)
			{
				if (v.StartsWith("form-control-", StringComparison.Ordinal))
					return v;
				return $"form-control-{v}";
			}
		}

		return null;
	}

	public string? GetSizeClass()
	{
		if (Size == Quark.Size.Default)
			return null;

		string? token = null;
		var isTheme = Size?.TryGetBootstrapThemeToken(out token) == true;
		if (isTheme && token is not null)
			return $"form-control-{token}";

		return Size?.ToString() != null ? $"form-control-{Size}" : null;
	}

	private string GetCurrentValue()
	{
		if (Date.HasValue)
		{
			return InputMode.Value switch
			{
				"date" => Date.Value.ToString("yyyy-MM-dd"),
				"datetime-local" => Date.Value.ToString("yyyy-MM-ddTHH:mm"),
				"month" => Date.Value.ToString("yyyy-MM"),
				_ => Date.Value.ToString("yyyy-MM-dd")
			};
		}
		else if (DateOnly.HasValue)
		{
			return InputMode.Value switch
			{
				"date" => DateOnly.Value.ToString("yyyy-MM-dd"),
				"datetime-local" => DateOnly.Value.ToString("yyyy-MM-ddTHH:mm"),
				"month" => DateOnly.Value.ToString("yyyy-MM"),
				_ => DateOnly.Value.ToString("yyyy-MM-dd")
			};
		}
		return string.Empty;
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender && ParentValidation is not null)
		{
			if (DateExpression is not null)
			{
				await ParentValidation.InitializeInputExpression(DateExpression);
			}
			else if (DateOnlyExpression is not null)
			{
				await ParentValidation.InitializeInputExpression(DateOnlyExpression);
			}
			ParentValidation.ValidationStatusChanged += OnParentValidationStatusChanged;
		}

		await base.OnAfterRenderAsync(firstRender);
	}

	private void OnParentValidationStatusChanged(object? sender, ValidationStatusChangedEventArgs e)
	{
		InvokeAsync(StateHasChanged);
	}

	private async Task HandleInput(ChangeEventArgs e)
	{
		var value = e.Value?.ToString();
		
		if (DateExpression is not null || Date.HasValue || DateChanged.HasDelegate)
		{
			if (DateTime.TryParse(value, out var dateValue))
			{
				Date = dateValue;
			}
			await DateChanged.InvokeIfHasDelegate(Date);
		}
		else if (DateOnlyExpression is not null || DateOnly.HasValue || DateOnlyChanged.HasDelegate)
		{
			if (System.DateOnly.TryParse(value, out var dateOnlyValue))
			{
				DateOnly = dateOnlyValue;
			}
			await DateOnlyChanged.InvokeIfHasDelegate(DateOnly);
		}

		await OnInput.InvokeIfHasDelegate(e);

		if (ParentValidation is not null)
		{
			ParentValidation.MarkTouched();
			await ParentValidation.NotifyInputChanged(ValidationValue);
		}
	}

	/// <summary>
	/// Disposes the component.
	/// </summary>
	public override void Dispose()
	{
		base.Dispose();

		if (ParentValidation is not null)
			ParentValidation.ValidationStatusChanged -= OnParentValidationStatusChanged;
	}

	private async Task HandleChange(ChangeEventArgs e)
	{
		var value = e?.Value?.ToString();
		
		if (DateExpression is not null || Date.HasValue || DateChanged.HasDelegate)
		{
			if (DateTime.TryParse(value, out var dateValue))
			{
				Date = dateValue;
			}
			await DateChanged.InvokeIfHasDelegate(Date);
		}
		else if (DateOnlyExpression is not null || DateOnly.HasValue || DateOnlyChanged.HasDelegate)
		{
			if (System.DateOnly.TryParse(value, out var dateOnlyValue))
			{
				DateOnly = dateOnlyValue;
			}
			await DateOnlyChanged.InvokeIfHasDelegate(DateOnly);
		}

		await OnChange.InvokeIfHasDelegate(e);

		if (ParentValidation is not null)
		{
			ParentValidation.MarkTouched();
			await ParentValidation.NotifyInputChanged(ValidationValue);
		}
	}

	private string GetInputModeString()
	{
		return InputMode.Value;
	}

	private Dictionary<string, object> BuildInputAttributes()
	{
		var attributes = new Dictionary<string, object>();

		// Add current value
		var currentValue = GetCurrentValue();
		if (!string.IsNullOrEmpty(currentValue))
			attributes["value"] = currentValue;

		// Add DateEdit-specific attributes
		if (Min != default)
		{
			var minString = InputMode.Value switch
			{
				"date" => Min.ToString("yyyy-MM-dd"),
				"datetime-local" => Min.ToString("yyyy-MM-ddTHH:mm"),
				"month" => Min.ToString("yyyy-MM"),
				_ => Min.ToString("yyyy-MM-dd")
			};
			attributes["min"] = minString;
		}
		else if (MinDateOnly != default)
		{
			var minString = InputMode.Value switch
			{
				"date" => MinDateOnly.ToString("yyyy-MM-dd"),
				"datetime-local" => MinDateOnly.ToString("yyyy-MM-ddTHH:mm"),
				"month" => MinDateOnly.ToString("yyyy-MM"),
				_ => MinDateOnly.ToString("yyyy-MM-dd")
			};
			attributes["min"] = minString;
		}

		if (Max != default)
		{
			var maxString = InputMode.Value switch
			{
				"date" => Max.ToString("yyyy-MM-dd"),
				"datetime-local" => Max.ToString("yyyy-MM-ddTHH:mm"),
				"month" => Max.ToString("yyyy-MM"),
				_ => Max.ToString("yyyy-MM-dd")
			};
			attributes["max"] = maxString;
		}
		else if (MaxDateOnly != default)
		{
			var maxString = InputMode.Value switch
			{
				"date" => MaxDateOnly.ToString("yyyy-MM-dd"),
				"datetime-local" => MaxDateOnly.ToString("yyyy-MM-ddTHH:mm"),
				"month" => MaxDateOnly.ToString("yyyy-MM"),
				_ => MaxDateOnly.ToString("yyyy-MM-dd")
			};
			attributes["max"] = maxString;
		}

		if (Step > 1)
			attributes["step"] = Step;

		// Pass through Input component properties
		if (Placeholder.HasContent())
			attributes["placeholder"] = Placeholder;

		if (Disabled)
			attributes["disabled"] = true;

		if (ReadOnly)
			attributes["readonly"] = true;

		if (Required)
			attributes["required"] = true;

		if (Size != Quark.Size.Default)
			attributes["size"] = Size;

		if (PlainText)
			attributes["plaintext"] = true;

		if (FloatingLabel)
			attributes["floatinglabel"] = true;

		if (Label.HasContent())
			attributes["label"] = Label;

		return attributes;
	}

}
