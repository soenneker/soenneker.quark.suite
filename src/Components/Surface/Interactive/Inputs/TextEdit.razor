@using System.Linq.Expressions
@using Soenneker.Blazor.Extensions.EventCallback

@namespace Soenneker.Quark
@inherits InputSurfaceElement
@implements ITextEdit

<div class="q-text-edit">
    <Input @ref="_inputComponent"
           Type="@Type"
           @attributes="BuildInputAttributes()"
           @bind-Value="Text"
           @bind-Value:expression="TextExpression"
           OnInput="HandleInput"
           OnChange="HandleChange"
           ValidationValueSelector="@(() => (object?)Text)" />
</div>

@code {
    // shadcn - new-york-v4
    /// <summary>
    /// Gets or sets the text value.
    /// </summary>
    [Parameter]
    public string? Text { get; set; }

    /// <summary>
    /// Gets or sets the callback invoked When the text value changes.
    /// </summary>
    [Parameter]
    public EventCallback<string?> TextChanged { get; set; }

    /// <summary>
    /// Gets or sets the expression that identifies the bound text value for validation.
    /// </summary>
    [Parameter]
    public Expression<Func<string?>>? TextExpression { get; set; }

    /// <summary>
    /// Gets or sets the maximum length of the text input.
    /// </summary>
    [Parameter]
    public int MaxLength { get; set; }

    /// <summary>
    /// Gets or sets the input type (e.g., "text", "email", "password").
    /// </summary>
    [Parameter]
    public string? Type { get; set; } = "text";

    /// <summary>
    /// Gets or sets the input mode hint for mobile keyboards.
    /// </summary>
    [Parameter]
    public TextInputMode? InputMode { get; set; }

    /// <summary>
    /// Gets or sets the size of the text input.
    /// </summary>
    [Parameter]
    public CssValue<SizeBuilder>? Size { get; set; } = Quark.Size.Default;

    /// <summary>
    /// Gets or sets whether the input should be rendered as plain text.
    /// </summary>
    [Parameter]
    public bool PlainText { get; set; }

    /// <summary>
    /// Gets or sets whether the input should use floating label styling.
    /// </summary>
    [Parameter]
    public bool FloatingLabel { get; set; }

    /// <summary>
    /// Gets or sets the label text for the input.
    /// </summary>
    [Parameter]
    public string? Label { get; set; }

    /// <summary>
    /// Gets or sets the callback invoked When the input value changes.
    /// </summary>
    [Parameter]
    public EventCallback<ChangeEventArgs> OnChange { get; set; }

    /// <summary>
    /// Gets or sets the callback invoked during input.
    /// </summary>
    [Parameter]
    public EventCallback<ChangeEventArgs> OnInput { get; set; }

    /// <summary>
    /// Gets or sets the parent validation context.
    /// </summary>
    [CascadingParameter(Name = nameof(ParentValidation))]
    public Validation? ParentValidation { get; set; }

    private Input? _inputComponent;

    public object? ValidationValue => Text;

    public string? GetValidationClass()
    {
        if (ParentValidation?.Status == ValidationStatus.Error) return "is-invalid";
        if (ParentValidation?.Status == ValidationStatus.Success) return "is-valid";
        return null;
    }

    public string? GetColorClass()
    {
        return null;
    }

    public string? GetSizeClass()
    {
        if (Size == Quark.Size.Default) return null;
        string? token = null;
        var isTheme = Size?.TryGetThemeToken(out token) == true;
        var sizeVal = token ?? Size?.ToString();
        return sizeVal?.ToLowerInvariant() switch { "sm" or "xs" => "h-9 text-xs", "lg" => "h-11 text-base", _ => null };
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && ParentValidation is not null && TextExpression is not null)
        {
            await ParentValidation.InitializeInputExpression(TextExpression);
            ParentValidation.ValidationStatusChanged += OnParentValidationStatusChanged;
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    private async void OnParentValidationStatusChanged(object? sender, ValidationStatusChangedEventArgs e)
    {
        await RefreshOffThread();
    }

    private async Task HandleInput(ChangeEventArgs e)
    {
        var next = e.Value?.ToString();
        var valueChanged = !string.Equals(Text, next, StringComparison.Ordinal);
        Text = next;
        if (valueChanged)
            await TextChanged.InvokeIfHasDelegate(Text);
        await OnInput.InvokeIfHasDelegate(e);
        if (ParentValidation is not null)
        {
            ParentValidation.MarkTouched();
            await ParentValidation.NotifyInputChanged(Text);
        }

        if (valueChanged)
        {
            InvalidateRender();
            Refresh();
        }
    }

    private async Task HandleChange(ChangeEventArgs e)
    {
        var next = e.Value?.ToString();
        var valueChanged = !string.Equals(Text, next, StringComparison.Ordinal);
        Text = next;
        if (valueChanged)
            await TextChanged.InvokeIfHasDelegate(Text);
        await OnChange.InvokeIfHasDelegate(e);
        if (ParentValidation is not null)
        {
            ParentValidation.MarkTouched();
            await ParentValidation.NotifyInputChanged(Text);
        }

        if (valueChanged)
        {
            InvalidateRender();
            Refresh();
        }
    }

    public override void Dispose()
    {
        base.Dispose();
        if (ParentValidation is not null)
            ParentValidation.ValidationStatusChanged -= OnParentValidationStatusChanged;
    }

    private Dictionary<string, object> BuildInputAttributes()
    {
        var attributes = new Dictionary<string, object>();

        // TextEdit-specific attributes that should land on the native <input> (via Input.AdditionalAttributes)
        if (MaxLength > 0) attributes["maxlength"] = MaxLength;
        if (Placeholder.HasContent()) attributes["placeholder"] = Placeholder;
        if (Disabled) attributes["disabled"] = true;
        if (ReadOnly) attributes["readonly"] = true;
        if (Required) attributes["required"] = true;

        // (Optional) semantic propsï¿½if your Input interprets them as classes/behavior, pass through:
        if (Size != Quark.Size.Default) attributes["size"] = Size;
        if (PlainText) attributes["plaintext"] = true;
        if (FloatingLabel) attributes["floatinglabel"] = true;
        if (Label.HasContent()) attributes["label"] = Label;
        if (InputMode is not null) attributes["inputmode"] = InputMode.Value;

        return attributes;
    }

    protected override void ComputeRenderKeyCore(ref HashCode hc)
    {
        hc.Add(Text);
        hc.Add(MaxLength);
        hc.Add(Type);
        hc.Add(InputMode);
        AddIf(ref hc, Size);
        hc.Add(PlainText);
        hc.Add(FloatingLabel);
        hc.Add(Label);
        hc.Add(Placeholder);
        hc.Add(Disabled);
        hc.Add(ReadOnly);
        hc.Add(Required);
    }
}