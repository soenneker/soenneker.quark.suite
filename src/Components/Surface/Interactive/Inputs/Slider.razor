@using System.Globalization
@using System.Linq.Expressions
@using Soenneker.Blazor.Extensions.EventCallback

@namespace Soenneker.Quark
@inherits InputSurfaceElement
@implements ISlider

@{
	var valuePercent = Max > Min ? ((Value - Min) / (Max - Min)) * 100.0 : 0.0;
	var valuePercentStr = valuePercent.ToString("F2", CultureInfo.InvariantCulture) + "%";
}

@* shadcn new-york-v4 ui/slider.tsx â€“ all styling via Tailwind, only --value-percent is inline for dynamic width/position *@
<div class="relative flex w-full touch-none select-none items-center data-[disabled]:opacity-50" style="--value-percent: @valuePercentStr" data-disabled="@(Disabled ? "true" : null)">
	<div class="relative h-1.5 w-full grow overflow-hidden rounded-full bg-muted">
		<div class="absolute h-full w-[var(--value-percent)] rounded-full bg-primary"></div>
	</div>
	<div class="absolute left-[var(--value-percent)] top-1/2 size-4 shrink-0 -translate-x-1/2 -translate-y-1/2 pointer-events-none rounded-full border border-primary bg-white shadow-sm transition-[color,box-shadow] after:absolute after:-inset-2 after:content-['']"></div>
	<input type="range"
	       class="absolute inset-0 z-10 m-0 h-full w-full cursor-pointer opacity-0"
	       value="@Value.ToString(CultureInfo.InvariantCulture)"
	       min="@Min.ToString(CultureInfo.InvariantCulture)"
	       max="@Max.ToString(CultureInfo.InvariantCulture)"
	       step="@Step.ToString(CultureInfo.InvariantCulture)"
	       disabled="@Disabled"
	       readonly="@ReadOnly"
	       required="@Required"
	       @oninput="HandleInput"
	       @onchange="HandleChange" />
</div>

@code {
	// shadcn - new-york-v4
	/// <summary>
	/// Gets or sets the slider value.
	/// </summary>
	[Parameter]
	public double Value { get; set; }

	/// <summary>
	/// Gets or sets the expression that identifies the bound value for validation.
	/// </summary>
	[Parameter]
	public Expression<Func<double>>? ValueExpression { get; set; }

	/// <summary>
	/// Gets or sets the minimum value of the slider.
	/// </summary>
	[Parameter]
	public double Min { get; set; }

	/// <summary>
	/// Gets or sets the maximum value of the slider.
	/// </summary>
	[Parameter]
	public double Max { get; set; } = 100;

	/// <summary>
	/// Gets or sets the step increment for the slider.
	/// </summary>
	[Parameter]
	public double Step { get; set; } = 1;

	/// <summary>
	/// Gets or sets the callback invoked When the slider value changes.
	/// </summary>
	[Parameter]
	public EventCallback<double> ValueChanged { get; set; }

	/// <summary>
	/// Gets or sets the size of the slider.
	/// </summary>
	[Parameter]
	public CssValue<SizeBuilder>? Size { get; set; } = Quark.Size.Default;

	/// <summary>
	/// Gets or sets whether the input should be rendered as plain text.
	/// </summary>
	[Parameter]
	public bool PlainText { get; set; }

	/// <summary>
	/// Gets or sets whether the input should use floating label styling.
	/// </summary>
	[Parameter]
	public bool FloatingLabel { get; set; }

	/// <summary>
	/// Gets or sets the label text for the slider.
	/// </summary>
	[Parameter]
	public string? Label { get; set; }

	/// <summary>
	/// Gets or sets the callback invoked When the input value changes.
	/// </summary>
	[Parameter]
	public EventCallback<ChangeEventArgs> OnChange { get; set; }

	/// <summary>
	/// Gets or sets the callback invoked during input.
	/// </summary>
	[Parameter]
	public EventCallback<ChangeEventArgs> OnInput { get; set; }

	/// <summary>
	/// Gets or sets the parent validation context.
	/// </summary>
	[CascadingParameter(Name = nameof(ParentValidation))]
	public Validation? ParentValidation { get; set; }

	private double _lastValue;
	private bool _valueChanged;
	public object? ValidationValue => Value;

	public string? GetColorClass() => null;

	public string? GetSizeClass()
	{
		if (Size == Quark.Size.Default) return null;
		string? token = null;
		var isTheme = Size?.TryGetThemeToken(out token) == true;
		var sizeVal = token ?? Size?.ToString();
		return sizeVal?.ToLowerInvariant() switch { "sm" or "xs" => "h-6", "lg" => "h-10", _ => null };
	}

	public string? GetValidationClass()
	{
		if (ParentValidation?.Status == ValidationStatus.Error)
			return "is-invalid";

		if (ParentValidation?.Status == ValidationStatus.Success)
			return "is-valid";

		return null;
	}

	private static double ParseDouble(ChangeEventArgs e)
	{
		if (e?.Value == null)
			return 0d;

		var text = e.Value.ToString();

		if (double.TryParse(text, NumberStyles.Any, CultureInfo.InvariantCulture, out var result))
			return result;

		return 0d;
	}

	private async Task HandleInput(ChangeEventArgs e)
	{
		var newValue = ParseDouble(e);
		if (Value != newValue)
		{
			Value = newValue;
			await ValueChanged.InvokeAsync(Value);
			_valueChanged = true;
		}
		await OnInput.InvokeIfHasDelegate(e);
	}

	private async Task HandleChange(ChangeEventArgs e)
	{
		var newValue = ParseDouble(e);
		if (Value != newValue)
		{
			Value = newValue;
			await ValueChanged.InvokeAsync(Value);
			_valueChanged = true;
		}
		await OnChange.InvokeIfHasDelegate(e);
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender && ParentValidation is not null && ValueExpression is not null)
		{
			await ParentValidation.InitializeInputExpression(ValueExpression);
		}

		_valueChanged = false;
		await base.OnAfterRenderAsync(firstRender);
	}

	protected override void OnParametersSet()
	{
		if (!Value.Equals(_lastValue))
		{
			_valueChanged = true;
			_lastValue = Value;
		}

		base.OnParametersSet();
	}

	protected override bool ShouldRender()
	{
		return _valueChanged || base.ShouldRender();
	}

	protected override void ComputeRenderKeyCore(ref HashCode hc)
	{
		hc.Add(Value);
		hc.Add(Min);
		hc.Add(Max);
		hc.Add(Step);
		AddIf(ref hc, Size);
		hc.Add(PlainText);
		hc.Add(FloatingLabel);
		hc.Add(Label);
		hc.Add(Placeholder);
		hc.Add(Disabled);
		hc.Add(ReadOnly);
		hc.Add(Required);
	}
}
