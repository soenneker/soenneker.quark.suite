@using System.Globalization
@using System.Linq.Expressions
@using Soenneker.Blazor.Extensions.EventCallback

@namespace Soenneker.Quark
@inherits InputSurfaceElement
@implements ISlider

<Input @ref="inputComponent" 
       Type="range"
       @attributes="BuildInputAttributes()" 
       OnInput="HandleInput"
       OnChange="HandleChange" />

@code {
	/// <summary>
	/// Gets or sets the slider value.
	/// </summary>
	[Parameter]
	public double Value { get; set; }

	/// <summary>
	/// Gets or sets the expression that identifies the bound value for validation.
	/// </summary>
	[Parameter]
	public Expression<Func<double>>? ValueExpression { get; set; }

	/// <summary>
	/// Gets or sets the minimum value of the slider.
	/// </summary>
	[Parameter]
	public double Min { get; set; }

	/// <summary>
	/// Gets or sets the maximum value of the slider.
	/// </summary>
	[Parameter]
	public double Max { get; set; } = 100;

	/// <summary>
	/// Gets or sets the step increment for the slider.
	/// </summary>
	[Parameter]
	public double Step { get; set; } = 1;

	/// <summary>
	/// Gets or sets the callback invoked when the slider value changes.
	/// </summary>
	[Parameter]
	public EventCallback<double> ValueChanged { get; set; }

	/// <summary>
	/// Gets or sets the size of the slider.
	/// </summary>
	[Parameter]
	public CssValue<SizeBuilder>? Size { get; set; } = Quark.Size.Default;

	/// <summary>
	/// Gets or sets whether the input should be rendered as plain text.
	/// </summary>
	[Parameter]
	public bool PlainText { get; set; }

	/// <summary>
	/// Gets or sets whether the input should use floating label styling.
	/// </summary>
	[Parameter]
	public bool FloatingLabel { get; set; }

	/// <summary>
	/// Gets or sets the label text for the slider.
	/// </summary>
	[Parameter]
	public string? Label { get; set; }

	/// <summary>
	/// Gets or sets the callback invoked when the input value changes.
	/// </summary>
	[Parameter]
	public EventCallback<ChangeEventArgs> OnChange { get; set; }

	/// <summary>
	/// Gets or sets the callback invoked during input.
	/// </summary>
	[Parameter]
	public EventCallback<ChangeEventArgs> OnInput { get; set; }

	/// <summary>
	/// Gets or sets the parent validation context.
	/// </summary>
	[CascadingParameter]
	public Validation? ParentValidation { get; set; }

	private Input? inputComponent;
	private double _lastValue;
	private bool _valueChanged;
	public object? ValidationValue => Value;

	public string? GetValidationClass()
	{
		if (ParentValidation?.Status == ValidationStatus.Error)
			return "is-invalid";

		if (ParentValidation?.Status == ValidationStatus.Success)
			return "is-valid";

		return null;
	}

	public string? GetColorClass()
	{
		if (BackgroundColor is not null && !BackgroundColor.Value.IsEmpty)
		{
			string? token = null;
			var isTheme = BackgroundColor.Value.TryGetBootstrapThemeToken(out token);

			if (isTheme && token is not null)
			{
				// Bootstrap theme token (e.g., "primary", "secondary")
				return $"form-control-{token}";
			}

			var v = BackgroundColor.Value.ToString().Trim();

			if (BackgroundColor.Value.IsCssClass)
			{
				if (v.StartsWith("form-control-", StringComparison.Ordinal))
					return v;
				return $"form-control-{v}";
			}
		}

		return null;
	}

	public string? GetSizeClass()
	{
		if (Size == Quark.Size.Default)
			return null;

		string? token = null;
		var isTheme = Size?.TryGetBootstrapThemeToken(out token) == true;
		if (isTheme && token is not null)
			return $"form-control-{token}";

		return Size?.ToString() != null ? $"form-control-{Size}" : null;
	}

	private static double ParseDouble(ChangeEventArgs e)
	{
		if (e?.Value == null)
			return 0d;

		var text = e.Value.ToString();

		if (double.TryParse(text, NumberStyles.Any, CultureInfo.InvariantCulture, out var result))
			return result;

		return 0d;
	}

	private async Task HandleInput(ChangeEventArgs e)
	{
		var newValue = ParseDouble(e);
		if (Value != newValue)
		{
			Value = newValue;
			await ValueChanged.InvokeAsync(Value);
			_valueChanged = true;
		}
		await OnInput.InvokeIfHasDelegate(e);
	}

	private async Task HandleChange(ChangeEventArgs e)
	{
		var newValue = ParseDouble(e);
		if (Value != newValue)
		{
			Value = newValue;
			await ValueChanged.InvokeAsync(Value);
			_valueChanged = true;
		}
		await OnChange.InvokeIfHasDelegate(e);
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender && ParentValidation is not null && ValueExpression is not null)
		{
			await ParentValidation.InitializeInputExpression(ValueExpression);
		}

		_valueChanged = false;
		await base.OnAfterRenderAsync(firstRender);
	}

	protected override void OnParametersSet()
	{
		if (!Value.Equals(_lastValue))
		{
			_valueChanged = true;
			_lastValue = Value;
		}

		base.OnParametersSet();
	}

	protected override bool ShouldRender()
	{
		return _valueChanged || base.ShouldRender();
	}

	private Dictionary<string, object> BuildInputAttributes()
	{
		var attributes = new Dictionary<string, object>();

		// Add Slider-specific attributes
		attributes["value"] = Value.ToString(CultureInfo.InvariantCulture);
		attributes["min"] = Min.ToString(CultureInfo.InvariantCulture);
		attributes["max"] = Max.ToString(CultureInfo.InvariantCulture);
		attributes["step"] = Step.ToString(CultureInfo.InvariantCulture);

		// Pass through Input component properties
		if (Placeholder.HasContent())
			attributes["placeholder"] = Placeholder;

		if (Disabled)
			attributes["disabled"] = true;

		if (ReadOnly)
			attributes["readonly"] = true;

		if (Required)
			attributes["required"] = true;

		if (Size != Quark.Size.Default)
			attributes["size"] = Size;

		if (PlainText)
			attributes["plaintext"] = true;

		if (FloatingLabel)
			attributes["floatinglabel"] = true;

		if (Label.HasContent())
			attributes["label"] = Label;

		// Override the Input component's default classes for slider-specific styling
		attributes["class"] = "form-range";

		return attributes;
	}
}