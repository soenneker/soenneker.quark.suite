@using System.Linq.Expressions
@using System.Reflection
@using Soenneker.Blazor.Extensions.EventCallback

@namespace Soenneker.Quark
@inherits InputSurfaceElement
@implements Soenneker.Quark.IValidationInput
@implements IMemoEdit

<textarea value="@Value" @oninput="HandleInput" @onchange="HandleChange" @attributes="BuildAttributes()"></textarea>

@code {
	/// <summary>
	/// Gets or sets the value of the textarea.
	/// </summary>
	[Parameter]
	public string? Value { get; set; }

	/// <summary>
	/// Gets or sets the number of rows for the textarea.
	/// </summary>
	[Parameter]
	public int Rows { get; set; } = 3;

	/// <summary>
	/// Gets or sets the maximum length of the input.
	/// </summary>
	[Parameter]
	public int MaxLength { get; set; }

	/// <summary>
	/// Gets or sets the minimum length of the input.
	/// </summary>
	[Parameter]
	public int MinLength { get; set; }

	/// <summary>
	/// Gets or sets the pattern for validation.
	/// </summary>
	[Parameter]
	public string? Pattern { get; set; }

	/// <summary>
	/// Gets or sets whether the textarea should auto-resize.
	/// </summary>
	[Parameter]
	public bool AutoResize { get; set; }

	/// <summary>
	/// Gets or sets the size of the input.
	/// </summary>
	[Parameter]
	public CssValue<SizeBuilder>? Size { get; set; } = Quark.Size.Default;

	/// <summary>
	/// Gets or sets the callback invoked when the value changes.
	/// </summary>
	[Parameter]
	public EventCallback<string?> ValueChanged { get; set; }

	/// <summary>
	/// Gets or sets the expression that identifies the bound value.
	/// </summary>
	[Parameter]
	public Expression<Func<string?>>? ValueExpression { get; set; }

	/// <summary>
	/// Gets or sets the callback invoked when the input changes.
	/// </summary>
	[Parameter]
	public EventCallback<ChangeEventArgs> OnChange { get; set; }

	/// <summary>
	/// Gets or sets the callback invoked when the input value changes.
	/// </summary>
	[Parameter]
	public EventCallback<ChangeEventArgs> OnInput { get; set; }

	[CascadingParameter(Name = nameof(ParentValidation))]
	public Validation? ParentValidation { get; set; }

    /// <summary>
    /// Gets the value used for validation.
    /// </summary>
    public object? ValidationValue => Value;

    protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender && ParentValidation is not null)
		{
			await ParentValidation.InitializeInput(this);
			
			if (ValueExpression is not null)
				await ParentValidation.InitializeInputExpression(ValueExpression);
			
			ParentValidation.ValidationStatusChanged += OnParentValidationStatusChanged;
		}

        await base.OnAfterRenderAsync(firstRender);
	}

	private async void OnParentValidationStatusChanged(object? sender, ValidationStatusChangedEventArgs e)
	{
		await RefreshOffThread();
	}

	private bool ShouldShowInvalid()
	{
		if (ParentValidation is null || ParentValidation.Status != ValidationStatus.Error)
			return false;

		PropertyInfo? showInvalidProp = ParentValidation.GetType().GetProperty("ShouldShowInvalid");
		bool showInvalid = showInvalidProp?.GetValue(ParentValidation) as bool? ?? true;
		return showInvalid;
	}

	private bool ShouldShowValid()
	{
		return ParentValidation?.Status == ValidationStatus.Success;
	}

	private string? GetValidationClass()
	{
		if (ShouldShowInvalid())
			return "border-destructive";
		return null;
	}

	private string? GetColorClass()
    {
        string? token = null;
        bool isTheme = BackgroundColor?.TryGetBootstrapThemeToken(out token) == true;

		if (isTheme && token is not null)
			return null;

		return null;
	}

	private string? GetSizeClass()
	{
		if (Size == Quark.Size.Default)
			return null;

		string? token = null;
		bool isTheme = Size?.TryGetBootstrapThemeToken(out token) == true;
		var sizeVal = token ?? Size?.ToString();
		if (string.IsNullOrEmpty(sizeVal)) return null;
		return sizeVal.ToLowerInvariant() switch { "sm" => "min-h-16 text-xs", "lg" => "min-h-24 text-base", _ => null };
	}

	protected override void BuildAttributesCore(Dictionary<string, object> attributes)
	{
		base.BuildAttributesCore(attributes);

		attributes.TryAdd("data-slot", "textarea");

		BuildClassAttribute(attributes, (ref cls) =>
		{
			AppendClass(ref cls, "q-memo-edit");
			// shadcn Textarea - exact copy from new-york-v4 ui/textarea.tsx
			AppendClass(ref cls, "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm");

			string? sizeClass = GetSizeClass();
			if (sizeClass != null)
				AppendClass(ref cls, sizeClass);

			string? validationClass = GetValidationClass();
			if (validationClass != null)
				AppendClass(ref cls, validationClass);
		});

		if (Placeholder.HasContent())
			attributes["placeholder"] = Placeholder;

		if (Disabled)
			attributes["disabled"] = true;

		if (ReadOnly)
			attributes["readonly"] = true;

		if (Required)
			attributes["required"] = true;

		if (Rows > 0)
			attributes["rows"] = Rows;

		if (MaxLength > 0)
			attributes["maxlength"] = MaxLength;

		if (MinLength > 0)
			attributes["minlength"] = MinLength;

		if (Pattern.HasContent())
			attributes["pattern"] = Pattern;

		if (AutoResize)
			BuildStyleAttribute(attributes, (ref sty) => AppendStyleDecl(ref sty, "resize: vertical; min-height: 60px;"));
	}

    private async Task HandleInput(ChangeEventArgs e)
	{
		string newValue = e?.Value?.ToString() ?? string.Empty;
		var valueChanged = false;
		if (Value != newValue)
		{
			Value = newValue;
			await ValueChanged.InvokeAsync(Value);
			valueChanged = true;
		}

		if (OnInput.HasDelegate)
			await OnInput.InvokeIfHasDelegate(e);

		if (ParentValidation is not null)
		{
			ParentValidation.MarkTouched();
			await ParentValidation.NotifyInputChanged(Value);
		}

		if (valueChanged)
		{
			InvalidateRender();
			Refresh();
		}
	}

    private async Task HandleChange(ChangeEventArgs e)
	{
		string newValue = e?.Value?.ToString() ?? string.Empty;
		var valueChanged = false;
		if (Value != newValue)
		{
			Value = newValue;
			await ValueChanged.InvokeAsync(Value);
			valueChanged = true;
		}

		await OnChange.InvokeIfHasDelegate(e);

		if (ParentValidation is not null)
		{
			ParentValidation.MarkTouched();
			await ParentValidation.NotifyInputChanged(Value);
		}

		if (valueChanged)
		{
			InvalidateRender();
			Refresh();
		}
	}

	public override void Dispose()
	{
		base.Dispose();

		if (ParentValidation is not null)
			ParentValidation.ValidationStatusChanged -= OnParentValidationStatusChanged;
	}

	protected override void ComputeRenderKeyCore(ref HashCode hc)
	{
		hc.Add(Value);
		hc.Add(Rows);
		hc.Add(MaxLength);
		hc.Add(MinLength);
		hc.Add(Pattern);
		hc.Add(AutoResize);
		AddIf(ref hc, Size);
		hc.Add(Placeholder);
		hc.Add(Disabled);
		hc.Add(ReadOnly);
		hc.Add(Required);
	}
}