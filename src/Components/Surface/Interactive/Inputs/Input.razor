@using System.Linq.Expressions
@using Soenneker.Blazor.Extensions.EventCallback

@namespace Soenneker.Quark
@inherits Soenneker.Quark.Element
@implements Soenneker.Quark.IValidationInput
@implements IInput

<input value="@Value"
       @oninput="HandleInput"
       @onchange="HandleChange"
       @attributes="BuildAttributes()"/>

@code {
    /// <summary>
    /// Gets or sets the input value.
    /// </summary>
    [Parameter]
    public string? Value { get; set; }

    /// <summary>
    /// Gets or sets the callback invoked when the value changes.
    /// </summary>
    [Parameter]
    public EventCallback<string?> ValueChanged { get; set; }

    /// <summary>
    /// Gets or sets the expression that identifies the bound value for validation.
    /// </summary>
    [Parameter]
    public Expression<Func<string?>>? ValueExpression { get; set; }

    /// <summary>
    /// Gets or sets the input type (e.g., "text", "email", "password").
    /// </summary>
    [Parameter]
    public virtual string? Type { get; set; }

    /// <summary>
    /// Gets or sets the placeholder text displayed when the input is empty.
    /// </summary>
    [Parameter]
    public string? Placeholder { get; set; }

    /// <summary>
    /// Gets or sets whether the input is disabled.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }

    /// <summary>
    /// Gets or sets whether the input is read-only.
    /// </summary>
    [Parameter]
    public bool ReadOnly { get; set; }

    /// <summary>
    /// Gets or sets whether the input is required.
    /// </summary>
    [Parameter]
    public bool Required { get; set; }

    /// <summary>
    /// Gets or sets the size of the input.
    /// </summary>
    [Parameter]
    public CssValue<SizeBuilder>? Size { get; set; } = Quark.Size.Default;

    /// <summary>
    /// Gets or sets whether the input should be rendered as plain text.
    /// </summary>
    [Parameter]
    public bool PlainText { get; set; }

    /// <summary>
    /// Gets or sets whether the input should use floating label styling.
    /// </summary>
    [Parameter]
    public bool FloatingLabel { get; set; }

    /// <summary>
    /// Gets or sets the label text for the input.
    /// </summary>
    [Parameter]
    public string? Label { get; set; }

    /// <summary>
    /// Gets or sets the callback invoked when the input value changes.
    /// </summary>
    [Parameter]
    public EventCallback<ChangeEventArgs> OnChange { get; set; }

    /// <summary>
    /// Gets or sets the callback invoked during input.
    /// </summary>
    [Parameter]
    public EventCallback<ChangeEventArgs> OnInput { get; set; }

    /// <summary>
    /// Gets or sets the parent validation context.
    /// </summary>
    [CascadingParameter(Name = nameof(ParentValidation))]
    public Validation? ParentValidation { get; set; }

    /// <summary>
    /// Gets or sets the function that selects the value used for validation.
    /// </summary>
    [Parameter]
    public Func<object?>? ValidationValueSelector { get; set; }

    /// <summary>
    /// Gets the value used for validation purposes.
    /// </summary>
    public virtual object? ValidationValue => ValidationValueSelector?.Invoke();

    private string? _lastValue;
    private bool _valueChanged;

    /// <summary>
    /// Called after the component has rendered.
    /// </summary>
    /// <param name="firstRender">True if this is the first render.</param>
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && ParentValidation is not null)
        {
            await ParentValidation.InitializeInput(this);
            ParentValidation.ValidationStatusChanged += OnParentValidationStatusChanged;
        }

        _valueChanged = false;
        await base.OnAfterRenderAsync(firstRender);
    }

    protected override void OnParametersSet()
    {
        if (!string.Equals(Value, _lastValue, StringComparison.Ordinal))
        {
            _valueChanged = true;
            _lastValue = Value;
        }

        base.OnParametersSet();
    }

    protected override bool ShouldRender()
    {
        return _valueChanged || base.ShouldRender();
    }

    private void OnParentValidationStatusChanged(object? sender, ValidationStatusChangedEventArgs e) => InvokeAsync(StateHasChanged);

    /// <summary>
    /// Handles the input event.
    /// </summary>
    /// <param name="e">The change event arguments.</param>
    protected virtual async Task HandleInput(ChangeEventArgs e)
    {
        var newValue = e.Value?.ToString();
        if (!string.Equals(Value, newValue, StringComparison.Ordinal))
        {
            Value = newValue;
            await ValueChanged.InvokeAsync(Value);
            _valueChanged = true;
        }

        if (OnInput.HasDelegate)
            await OnInput.InvokeIfHasDelegate(e);

        if (ParentValidation is not null)
        {
            var valueObj = ValidationValue;
            await ParentValidation.NotifyInputChanged(valueObj);
        }
    }

    /// <summary>
    /// Handles the change event.
    /// </summary>
    /// <param name="e">The change event arguments.</param>
    protected virtual async Task HandleChange(ChangeEventArgs e)
    {
        var newValue = e.Value?.ToString();
        if (!string.Equals(Value, newValue, StringComparison.Ordinal))
        {
            Value = newValue;
            await ValueChanged.InvokeAsync(Value);
            _valueChanged = true;
        }

        await OnChange.InvokeIfHasDelegate(e);

        if (ParentValidation is not null)
        {
            var valueObj = ValidationValue;
            await ParentValidation.NotifyInputChanged(valueObj);
        }
    }

    private bool ShouldShowInvalid()
    {
        if (ParentValidation is null || ParentValidation.Status != ValidationStatus.Error)
            return false;

        var showInvalidProp = ParentValidation.GetType().GetProperty("ShouldShowInvalid");
        var showInvalid = showInvalidProp?.GetValue(ParentValidation) as bool? ?? true;
        return showInvalid;
    }

    private bool ShouldShowValid() => ParentValidation?.Status == ValidationStatus.Success;

    /// <summary>
    /// Gets the validation class for the input based on validation status.
    /// </summary>
    /// <returns>The validation class name, or null if no validation class should be applied.</returns>
    public virtual string? GetValidationClass()
    {
        if (ShouldShowInvalid()) return "is-invalid";
        if (ShouldShowValid()) return "is-valid";
        return null;
    }

    /// <summary>
    /// Gets the color class for the input based on background color.
    /// </summary>
    /// <returns>The color class name, or null if no color class should be applied.</returns>
    public virtual string? GetColorClass()
    {
        if (BackgroundColor is not null && !BackgroundColor.Value.IsEmpty)
        {
            string? token = null;
            var isTheme = BackgroundColor.Value.TryGetBootstrapThemeToken(out token);

            if (isTheme && token is not null)
                return $"form-control-{token}";

            var v = BackgroundColor.Value.ToString().Trim();
            if (BackgroundColor.Value.IsCssClass)
                return v.StartsWith("form-control-", StringComparison.Ordinal) ? v : $"form-control-{v}";
        }

        return null;
    }

    /// <summary>
    /// Gets the size class for the input.
    /// </summary>
    /// <returns>The size class name, or null if no size class should be applied.</returns>
    public virtual string? GetSizeClass()
    {
        if (Size == Quark.Size.Default) return null;

        string? token = null;
        var isTheme = Size?.TryGetBootstrapThemeToken(out token) == true;
        if (isTheme && token is not null) return $"form-control-{token}";

        return Size?.ToString() != null ? $"form-control-{Size}" : null;
    }

    /// <summary>
    /// Gets the input type, defaulting to "text" if not specified.
    /// </summary>
    /// <returns>The input type string.</returns>
    protected virtual string GetInputType() => Type ?? "text";

    /// <summary>
    /// Builds the attributes dictionary for the input component.
    /// </summary>
    /// <returns>A dictionary of HTML attributes.</returns>
    protected override void BuildAttributesCore(Dictionary<string, object> attributes)
    {
        base.BuildAttributesCore(attributes);

        BuildClassAttribute(attributes, (ref cls) =>
        {
            AppendClass(ref cls, "q-input");
            AppendClass(ref cls, PlainText ? "form-control-plaintext" : "form-control");

            var colorClass = GetColorClass();
            if (colorClass is not null) AppendClass(ref cls, colorClass);

            var sizeClass = GetSizeClass();
            if (sizeClass is not null) AppendClass(ref cls, sizeClass);

            var validationClass = GetValidationClass();
            if (validationClass is not null) AppendClass(ref cls, validationClass);
        });

        attributes["type"] = GetInputType();

        if (BackgroundColor is not null && !BackgroundColor.Value.IsEmpty && !BackgroundColor.Value.IsCssClass)
        {
            var v = BackgroundColor.Value.ToString().Trim();
            attributes["style"] = $"border-color:{v};";
        }

        if (Placeholder.HasContent()) attributes["placeholder"] = Placeholder;
        if (Disabled) attributes["disabled"] = true;
        if (ReadOnly) attributes["readonly"] = true;
        if (Required) attributes["required"] = true;
    }

    public override void Dispose()
    {
        base.Dispose();
        if (ParentValidation is not null)
            ParentValidation.ValidationStatusChanged -= OnParentValidationStatusChanged;
    }

    protected override void ComputeRenderKeyCore(ref HashCode hc)
    {
        hc.Add(Value);
        hc.Add(Type);
        hc.Add(Placeholder);
        hc.Add(Disabled);
        hc.Add(ReadOnly);
        hc.Add(Required);
        AddIf(ref hc, Size);
        hc.Add(PlainText);
        hc.Add(FloatingLabel);
        hc.Add(Label);
    }
}