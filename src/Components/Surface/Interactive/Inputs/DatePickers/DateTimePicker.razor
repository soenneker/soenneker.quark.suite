@using System.Globalization
@using System.Linq.Expressions
@using Microsoft.JSInterop
@using Soenneker.Blazor.Extensions.EventCallback

@namespace Soenneker.Quark
@inherits Soenneker.Quark.Element
@implements Soenneker.Quark.IValidationInput
@implements IDateTimePicker

<div OnElementRefReady="HandleContainerRefReady" @attributes="GetContainerAttributes()">
    <input @ref="_ref" type="text" value="@(Value.HasValue ? FormatDisplay(Value.Value) : "")" @attributes="BuildAttributes()" />

    @if (_open)
    {
        <div class="quark-date-backdrop" style="position: fixed; inset: 0; z-index: 1075;" @onclick="ClosePanel"></div>
        <div @attributes="BuildPanelAttributes()" @onclick:stopPropagation="true">
            <div class="qcal-header flex items-center justify-between">
                <button type="button" class="qcal-nav inline-flex h-8 items-center justify-center rounded-md border border-input bg-background px-2 text-sm shadow-xs hover:bg-accent hover:text-accent-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring" @onclick="PrevMonth">‹</button>
                <div class="qcal-title font-semibold">@_displayMonth.ToString("MMMM yyyy", CultureInfo.CurrentUICulture)</div>
                <button type="button" class="qcal-nav inline-flex h-8 items-center justify-center rounded-md border border-input bg-background px-2 text-sm shadow-xs hover:bg-accent hover:text-accent-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring" @onclick="NextMonth">›</button>
            </div>
            <div class="qcal-grid mt-2">
                @foreach (string dow in _dayNames)
                {
                    <div class="qcal-dow text-muted">@dow</div>
                }
                @foreach (Cell day in BuildMonthCells())
                {
                    string css = day.InMonth ? "qcal-day" : "qcal-day text-muted";
                    if (day.Date == DateOnly.FromDateTime(DateTime.Today))
                    {
                        css += " qcal-today";
                    }
                    if (Value.HasValue && day.Date == DateOnly.FromDateTime(Value.Value))
                    {
                        css += " qcal-selected";
                    }
                    if (day.Disabled)
                    {
                        css += " disabled";
                    }

                    <button type="button" class="@css" disabled="@day.Disabled" @onclick="() => SelectDate(day.Date)">@day.Date.Day</button>
                }
            </div>

            <div class="qcal-time qcal-time-full">
                <div class="qnum-wrapper">
                    <input class="qnum-input qnum-hour" type="number" aria-label="Hour" step="1" min="1" max="12" value="@DisplayHour"
                           @oninput="OnHourInput" @onwheel="OnHourWheel" @onkeydown="OnHourKeyDown" />
                    <span class="qnum-arrowUp" @onclick="IncrementHour"></span>
                    <span class="qnum-arrowDown" @onclick="DecrementHour"></span>
                </div>
                <span class="qcal-time-separator">:</span>
                <div class="qnum-wrapper">
                    <input class="qnum-input qnum-minute" type="number" aria-label="Minute" step="@_minuteStep" min="0" max="59" value="@_minute"
                           @oninput="OnMinuteInput" @onwheel="OnMinuteWheel" @onkeydown="OnMinuteKeyDown" />
                    <span class="qnum-arrowUp" @onclick="IncrementMinute"></span>
                    <span class="qnum-arrowDown" @onclick="DecrementMinute"></span>
                </div>
                <div class="qcal-time-ampm">
                    <button type="button" class="qcal-time-ampm-toggle" title="Click to toggle" @onclick="ToggleAmPm">@(_isAm ? "AM" : "PM")</button>
                </div>
            </div>
        </div>
    }
</div>

@code {
    // shadcn - new-york-v4
    /// <summary>
    /// Gets or sets the date-time value.
    /// </summary>
    [Parameter]
    public DateTime? Value { get; set; }

    /// <summary>
    /// Gets or sets the expression that identifies the bound value.
    /// </summary>
    [Parameter]
    public Expression<Func<DateTime?>>? ValueExpression { get; set; }

    /// <summary>
    /// Gets or sets the placeholder text.
    /// </summary>
    [Parameter]
    public string? Placeholder { get; set; }

    /// <summary>
    /// Gets or sets whether the date-time picker is disabled.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }

    /// <summary>
    /// Gets or sets whether the date-time picker is read-only.
    /// </summary>
    [Parameter]
    public bool ReadOnly { get; set; }

    /// <summary>
    /// Gets or sets whether the date-time picker is required.
    /// </summary>
    [Parameter]
    public bool Required { get; set; }

    /// <summary>
    /// Gets or sets the minimum date-time value.
    /// </summary>
    [Parameter]
    public DateTime? Min { get; set; }

    /// <summary>
    /// Gets or sets the maximum date-time value.
    /// </summary>
    [Parameter]
    public DateTime? Max { get; set; }

    /// <summary>
    /// Gets or sets the size of the date-time picker.
    /// </summary>
    [Parameter]
    public CssValue<SizeBuilder>? Size { get; set; } = Quark.Size.Default;

    /// <summary>
    /// Gets or sets the callback invoked When the value changes.
    /// </summary>
    [Parameter]
    public EventCallback<DateTime?> ValueChanged { get; set; }

    /// <summary>
    /// Gets or sets the callback invoked When the input changes.
    /// </summary>
    [Parameter]
    public EventCallback<ChangeEventArgs> OnChange { get; set; }

    /// <summary>
    /// Gets or sets the callback invoked When the input value changes.
    /// </summary>
    [Parameter]
    public EventCallback<ChangeEventArgs> OnInput { get; set; }

    [CascadingParameter(Name = nameof(ParentValidation))]
    public Validation? ParentValidation { get; set; }

    /// <summary>
    /// Gets the value used for validation.
    /// </summary>
    public object? ValidationValue => Value;

    private ElementReference _ref;
    private ElementReference _containerRef;
    private DotNetObjectReference<DateTimePickerOutsideCloseProxy>? _outsideRef;
    private bool _open;
    private DateOnly _displayMonth = DateOnly.FromDateTime(DateTime.Today);
    private string[] _dayNames = [];
    private DateOnly? _pendingDate;
    private int _hour; // 0-23
    private int _minute; // 0-59
    private bool _isAm;
    private const int _minuteStep = 1;

    private static DateTime? Parse(ChangeEventArgs e)
    {
        if (e?.Value == null)
            return null;

        var text = e.Value.ToString();
        // Accept common formats (with T or space)
        if (text.IsNullOrWhiteSpace())
            return null;

        string normalized = text.Trim();
        if (normalized.Contains(' ') && !normalized.Contains('T'))
            normalized = normalized.Replace(' ', 'T');

        if (DateTime.TryParse(normalized, CultureInfo.InvariantCulture, DateTimeStyles.AssumeLocal, out DateTime result))
            return result;

        return null;
    }

    private async Task HandleInput(ChangeEventArgs e)
    {
        DateTime? next = Parse(e);
        bool valueChanged = Value != next;
        Value = next;
        if (valueChanged)
            await ValueChanged.InvokeIfHasDelegate(Value);
        await OnInput.InvokeIfHasDelegate(e);

        if (ParentValidation is not null)
            await ParentValidation.NotifyInputChanged(Value);

        if (valueChanged)
        {
            InvalidateRender();
            Refresh();
        }
    }

    private async Task HandleChange(ChangeEventArgs e)
    {
        DateTime? next = Parse(e);
        bool valueChanged = Value != next;
        Value = next;
        if (valueChanged)
            await ValueChanged.InvokeIfHasDelegate(Value);
        await OnChange.InvokeIfHasDelegate(e);

        if (ParentValidation is not null)
            await ParentValidation.NotifyInputChanged(Value);

        if (valueChanged)
        {
            InvalidateRender();
            Refresh();
        }
    }

    private string? GetSizeClass()
    {
        if (Size == Quark.Size.Default) return null;
        string? token = null;
        bool isTheme = Size?.TryGetThemeToken(out token) == true;
        var sizeVal = token ?? Size?.ToString();
        return sizeVal?.ToLowerInvariant() switch { "sm" or "xs" => "h-9 text-xs", "lg" => "h-11 text-base", _ => null };
    }


    private string? GetValidationClass()
    {
        if (ParentValidation?.Status == ValidationStatus.Error)
            return "is-invalid";

        if (ParentValidation?.Status == ValidationStatus.Success)
            return "is-valid";

        return null;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && ParentValidation is not null)
        {
            await ParentValidation.InitializeInput(this);

            if (ValueExpression is not null)
            {
                await ParentValidation.InitializeInputExpression(ValueExpression);
            }
        }

        if (firstRender)
        {
            _outsideRef = DotNetObjectReference.Create(new DateTimePickerOutsideCloseProxy(this));

            InitializeDayNames();
            if (Value.HasValue)
            {
                _displayMonth = DateOnly.FromDateTime(Value.Value);
                _hour = Value.Value.Hour;
                _minute = Value.Value.Minute;
            }
            else
            {
                _displayMonth = DateOnly.FromDateTime(DateTime.Today);
                DateTime now = DateTime.Now;
                _hour = now.Hour;
                _minute = now.Minute;
            }

            _isAm = _hour < 12;
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    private static string FormatDisplay(DateTime dt) => dt.ToString("yyyy-MM-dd HH:mm", CultureInfo.InvariantCulture);
    private int DisplayHour => _hour % 12 == 0 ? 12 : _hour % 12;

    protected override void BuildAttributesCore(Dictionary<string, object> attributes)
    {
        base.BuildAttributesCore(attributes);
        BuildClassAttribute(attributes, (ref cls) =>
        {
            AppendClass(ref cls, "q-date-time-picker");
            AppendClass(ref cls, "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 transition-colors md:text-sm");
            
            string? sizeClass = GetSizeClass();
            if (sizeClass != null)
                AppendClass(ref cls, sizeClass);
                
            string? validationClass = GetValidationClass();
            if (validationClass != null)
                AppendClass(ref cls, validationClass);
        });

        if (Placeholder.HasContent())
            attributes["placeholder"] = Placeholder!;

        if (Disabled)
            attributes["disabled"] = true;

        if (ReadOnly)
            attributes["readonly"] = true;

        if (Required)
            attributes["required"] = true;

        // min/max intentionally omitted for text input (handled in panel)

        attributes["onclick"] = EventCallback.Factory.Create<MouseEventArgs>(this, OpenPanel);
        attributes["onfocus"] = EventCallback.Factory.Create<FocusEventArgs>(this, OpenPanel);

        attributes["autocomplete"] = "off";
        attributes["oninput"] = EventCallback.Factory.Create<ChangeEventArgs>(this, HandleInput);
        attributes["onchange"] = EventCallback.Factory.Create<ChangeEventArgs>(this, HandleChange);
    }

    private Task HandleContainerRefReady(ElementReference el)
    {
        _containerRef = el;
        return Task.CompletedTask;
    }

    private static Dictionary<string, object> GetContainerAttributes()
    {
        var attrs = new Dictionary<string, object>(2);
        BuildClassAttribute(attrs, (ref cls) =>
        {
            AppendClass(ref cls, "relative inline-block quark-date-container q-date-container");
        });
        return attrs;
    }

    private static Dictionary<string, object> BuildPanelAttributes()
    {
        var attrs = new Dictionary<string, object>(4);

        BuildClassAttribute(attrs, (ref cls) =>
        {
            AppendClass(ref cls, "quark-calendar-panel q-calendar-panel");
            AppendClass(ref cls, "shadow-lg border rounded-lg bg-background p-3");
        });

        BuildStyleAttribute(attrs, (ref sty) =>
        {
            AppendStyleDecl(ref sty, "position: absolute");
            AppendStyleDecl(ref sty, "top: calc(100% + .25rem)");
            AppendStyleDecl(ref sty, "left: 0");
            AppendStyleDecl(ref sty, "z-index: 1080");
            AppendStyleDecl(ref sty, "min-width: 18rem");
        });
        return attrs;
    }

    private void InitializeDayNames()
    {
        CultureInfo culture = CultureInfo.CurrentCulture;
        DayOfWeek first = culture.DateTimeFormat.FirstDayOfWeek;
        string[] names = culture.DateTimeFormat.AbbreviatedDayNames;
        _dayNames = Enumerable.Range(0, 7)
            .Select(i => names[((int)first + i) % 7])
            .ToArray();
    }

    private readonly record struct Cell(DateOnly Date, bool InMonth, bool Disabled);

    private IEnumerable<Cell> BuildMonthCells()
    {
        var firstOfMonth = new DateOnly(_displayMonth.Year, _displayMonth.Month, 1);
        CultureInfo culture = CultureInfo.CurrentCulture;
        DayOfWeek startDow = culture.DateTimeFormat.FirstDayOfWeek;
        int offset = ((int)firstOfMonth.DayOfWeek - (int)startDow + 7) % 7;
        DateOnly gridStart = firstOfMonth.AddDays(-offset);

        for (var i = 0; i < 42; i++)
        {
            DateOnly d = gridStart.AddDays(i);
            bool inMonth = d.Month == _displayMonth.Month;
            bool disabled = (Min.HasValue && d < DateOnly.FromDateTime(Min.Value)) || (Max.HasValue && d > DateOnly.FromDateTime(Max.Value));
            yield return new Cell(d, inMonth, disabled);
        }
    }

    private Task OpenPanel()
    {
        if (!_open)
            _open = true;
        InvalidateRender();
        Refresh();
        return Task.CompletedTask;
    }

    internal async Task ClosePanel()
    {
        if (_open)
            _open = false;
        await RefreshOffThread();
    }


    private async Task Commit()
    {
        DateOnly date = _pendingDate ?? (Value.HasValue ? DateOnly.FromDateTime(Value.Value) : DateOnly.FromDateTime(DateTime.Today));
        var dt = new DateTime(date.Year, date.Month, date.Day, _hour, _minute, 0);
        
        if (Value != dt)
        {
            Value = dt;
            await ValueChanged.InvokeAsync(Value);
        }
        
        if (ParentValidation is not null)
        {
            ParentValidation.MarkTouched();
            await ParentValidation.NotifyInputChanged(Value);
        }

        InvalidateRender();
        Refresh();
    }

    private async Task SelectDate(DateOnly date)
    {
        if ((Min.HasValue && date < DateOnly.FromDateTime(Min.Value)) || (Max.HasValue && date > DateOnly.FromDateTime(Max.Value)))
            return;

        _pendingDate = date;
        await Commit();
    }

    private Task IncrementHour() { _hour = (_hour + 1) % 24; _isAm = _hour < 12; return Commit(); }
    private Task DecrementHour() { _hour = (_hour + 23) % 24; _isAm = _hour < 12; return Commit(); }
    private Task IncrementMinute() { _minute = (_minute + _minuteStep) % 60; return Commit(); }
    private Task DecrementMinute() { _minute = (_minute + 60 - _minuteStep) % 60; return Commit(); }
    private Task SetAmPm(bool am) { _isAm = am; if (am && _hour >= 12) _hour -= 12; if (!am && _hour < 12) _hour += 12; return Commit(); }
    private Task ToggleAmPm() => SetAmPm(!_isAm);
    private Task OnHourWheel(WheelEventArgs e) => e.DeltaY < 0 ? IncrementHour() : DecrementHour();
    private Task OnMinuteWheel(WheelEventArgs e) => e.DeltaY < 0 ? IncrementMinute() : DecrementMinute();

    private Task OnHourKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "ArrowUp") return IncrementHour();
        if (e.Key == "ArrowDown") return DecrementHour();
        return Task.CompletedTask;
    }

    private Task OnMinuteKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "ArrowUp") return IncrementMinute();
        if (e.Key == "ArrowDown") return DecrementMinute();
        return Task.CompletedTask;
    }

    private Task OnHourInput(ChangeEventArgs e)
    {
        if (e?.Value is null) return Task.CompletedTask;
        if (int.TryParse(e.Value.ToString(), out int v))
        {
            v = Math.Clamp(v, 1, 12);
            // preserve am/pm while mapping 12->0 for AM case
            int baseHour = _isAm ? 0 : 12;
            _hour = v % 12 + baseHour;
            return Commit();
        }
        return Task.CompletedTask;
    }

    private Task OnMinuteInput(ChangeEventArgs e)
    {
        if (e?.Value is null) return Task.CompletedTask;
        if (int.TryParse(e.Value.ToString(), out int v))
        {
            v = (v % 60 + 60) % 60;
            _minute = v;
            return Commit();
        }
        return Task.CompletedTask;
    }

    private Task PrevMonth()
    {
        _displayMonth = _displayMonth.AddMonths(-1);
        InvalidateRender();
        Refresh();
        return Task.CompletedTask;
    }

    private Task NextMonth()
    {
        _displayMonth = _displayMonth.AddMonths(1);
        InvalidateRender();
        Refresh();
        return Task.CompletedTask;
    }

    protected override Task OnDisposeAsync()
    {
        _outsideRef?.Dispose();
        return Task.CompletedTask;
    }

    protected override void ApplyBackgroundColor(ref PooledStringBuilder sty, ref PooledStringBuilder cls)
    {
        if (BackgroundColor is { IsEmpty: false })
        {
            string? token = null;
            bool isTheme = BackgroundColor.Value.TryGetThemeToken(out token);

            var result = BackgroundColor.ToString();
            if (!result.HasContent()) return;

            if (BackgroundColor.Value.IsCssStyle)
                AppendStyleDecl(ref sty, $"background-color: {result}");
        }
    }

    protected override void ComputeRenderKeyCore(ref HashCode hc)
    {
        hc.Add(Value);
        hc.Add(Placeholder);
        hc.Add(Disabled);
        hc.Add(ReadOnly);
        hc.Add(Required);
        hc.Add(Min);
        hc.Add(Max);
        AddIf(ref hc, Size);
    }
}