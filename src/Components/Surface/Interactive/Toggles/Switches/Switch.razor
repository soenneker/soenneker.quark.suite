@using Soenneker.Blazor.Extensions.EventCallback

@namespace Soenneker.Quark
@inherits ToggleElement
@implements Soenneker.Quark.IValidationInput
@implements ISwitch
@inject ISwitchInterop SwitchInterop

<div @attributes="BuildWrapperAttributes()">
    <input id="@Id" type="checkbox" checked="@Checked" @onclick="HandleClick" @onchange="HandleChange" @attributes="BuildInputAttributes()"/>
    @if (ChildContent != null)
    {
        <label @attributes="BuildLabelAttributes()">@ChildContent</label>
    }
    else if (Label.HasContent())
    {
        <label @attributes="BuildLabelAttributes()">@Label</label>
    }
</div>

@code {
    public override string? Id { get; set; } = $"switch-{Guid.NewGuid():N}";

    /// <summary>
    /// Gets or sets the label text for the switch.
    /// </summary>
    [Parameter]
    public string? Label { get; set; }

    /// <summary>
    /// Gets or sets the size of the switch.
    /// </summary>
    [Parameter]
    public CssValue<SizeBuilder>? Size { get; set; } = Quark.Size.Default;

    /// <summary>
    /// Gets or sets the callback invoked when the switch state changes.
    /// </summary>
    [Parameter]
    public EventCallback<ChangeEventArgs> OnChange { get; set; }

    [CascadingParameter]
    public Validation? ParentValidation { get; set; }

    /// <summary>
    /// Gets the value used for validation.
    /// </summary>
    public object? ValidationValue => Checked;

    private bool _initialized;
    private bool _lastChecked;
    private bool _checkedChanged;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_initialized)
        {
            await SwitchInterop.Initialize();
            _initialized = true;
        }

        if (firstRender && ParentValidation is not null)
        {
            if (CheckedExpression is not null)
                await ParentValidation.InitializeInputExpression(CheckedExpression);

            await ParentValidation.InitializeInput(this);
        }

        _checkedChanged = false; // reset after render
        await base.OnAfterRenderAsync(firstRender);
    }

    protected override void OnParametersSet()
    {
        if (Checked != _lastChecked)
        {
            _checkedChanged = true;
            _lastChecked = Checked;
        }

        base.OnParametersSet();
    }

    protected override bool ShouldRender()
    {
        return _checkedChanged || base.ShouldRender();
    }

    private string? GetColorClass()
    {
        if (BackgroundColor is not null && !BackgroundColor.Value.IsEmpty)
        {
            string? token = null;
            var isTheme = BackgroundColor.Value.TryGetBootstrapThemeToken(out token);

            if (isTheme && token is not null)
            {
                // Bootstrap theme token (e.g., "primary", "secondary")
                return $"form-check-input-{token}";
            }

            var v = BackgroundColor.Value.ToString().Trim();

            if (BackgroundColor.Value.IsCssClass)
            {
                if (v.StartsWith("form-check-input-", StringComparison.Ordinal))
                    return v;
                return $"form-check-input-{v}";
            }
        }

        return null;
    }

    private string? GetSizeClass()
    {
        if (Size == Quark.Size.Default)
            return null;

        string? token = null;
        var isTheme = Size?.TryGetBootstrapThemeToken(out token) == true;
        if (isTheme && token is not null)
            return $"form-check-input-{token}";

        return Size?.ToString() != null ? $"form-check-input-{Size}" : null;
    }

    protected Dictionary<string, object> BuildWrapperAttributes()
    {
        var attributes = new Dictionary<string, object>();

        BuildClassAttribute(attributes, (ref cls) =>
        {
            AppendClass(ref cls, "q-switch");
            AppendClass(ref cls, "form-check");
            AppendClass(ref cls, "q-form-check");
            AppendClass(ref cls, "form-switch");
            AppendClass(ref cls, "q-form-switch");
        });

        // Only apply non-color related attributes to the wrapper
        if (Id.HasContent())
            attributes["id"] = Id;

        if (Style.HasContent())
            attributes["style"] = Style;

        // Don't apply BackgroundColor to wrapper - it should only go to the input
        return attributes;
    }

    private Dictionary<string, object> BuildLabelAttributes()
    {
        var attributes = new Dictionary<string, object>();
        BuildClassAttribute(attributes, (ref cls) => AppendClass(ref cls, "form-check-label"));
        attributes["for"] = Id!;
        return attributes;
    }

    private Dictionary<string, object> BuildInputAttributes()
    {
        var attributes = new Dictionary<string, object>();

        BuildClassAttribute(attributes, (ref cls) =>
        {
            AppendClass(ref cls, "form-check-input");

            var colorClass = GetColorClass();
            if (colorClass != null)
                AppendClass(ref cls, colorClass);

            var sizeClass = GetSizeClass();
            if (sizeClass != null)
                AppendClass(ref cls, sizeClass);

            var validationClass = GetValidationClass();
            if (validationClass != null)
                AppendClass(ref cls, validationClass);
        });

        // Handle custom CSS colors using BackgroundColor
        if (BackgroundColor is not null && !BackgroundColor.Value.IsEmpty && !BackgroundColor.Value.IsCssClass)
        {
            var v = BackgroundColor.Value.ToString().Trim();
            // BackgroundColor already handles background-color, just add border-color
            BuildStyleAttribute(attributes, (ref sty) => AppendStyleDecl(ref sty, $"border-color:{v}"));
        }

        if (Disabled)
            attributes["disabled"] = true;

        return attributes;
    }

    private string? GetValidationClass()
    {
        if (ParentValidation?.Status == ValidationStatus.Error)
            return "is-invalid";
        if (ParentValidation?.Status == ValidationStatus.Success)
            return "is-valid";

        return null;
    }

    protected override async Task HandleClick(MouseEventArgs args)
    {
        if (Disabled)
            return;

        // Toggle the checked state
        Checked = !Checked;
        await CheckedChanged.InvokeAsync(Checked);

        _checkedChanged = true;
        StateHasChanged();

        if (ParentValidation is not null)
        {
            ParentValidation.MarkTouched();
            await ParentValidation.NotifyInputChanged(Checked);
        }
    }

    private async Task HandleChange(ChangeEventArgs e)
    {
        // This is called after onclick, primarily for OnChange event callback
        await OnChange.InvokeIfHasDelegate(e);
    }

}