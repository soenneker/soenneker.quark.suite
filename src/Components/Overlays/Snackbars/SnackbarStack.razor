@using Timer = System.Timers.Timer

@namespace Soenneker.Quark
@inherits Soenneker.Quark.Element
@implements ISnackbarStack
@inject ISnackbarInterop SnackbarInterop

<CascadingValue Value="@this" IsFixed="true">
    @ChildContent

    @foreach (var locationGroup in _notifications.GroupBy(n => n.Location ?? EffectiveLocation))
    {
        <div @attributes="BuildAttributes(locationGroup.Key)">
            @foreach (var item in locationGroup)
            {
                <Snackbar @key="@item.Key"
                          Key="@item.Key"
                          Visible="@item.Visible"
                          BackgroundColor="@item.Color"
                          AutoHideDelay="@(item.HideDelay ?? EffectiveDefaultDelay)"
                          Closed="@(async e => await HandleClosed(e.Key, e.CloseReason))">
                    @if (item.Content != null)
                    {
                        @item.Content
                    }
                    else
                    {
                        @item.Message
                    }
                </Snackbar>
            }
        </div>
    }
</CascadingValue>

@code {
    private readonly List<SnackbarNotificationItem> _notifications = [];
    private readonly Dictionary<string, Timer> _autoHideTimers = new(StringComparer.Ordinal);

    private bool _isInitialized;
    private bool _disposed;

    [Parameter]
    public SnackbarLocation? Location { get; set; }

    [Parameter]
    public int? DefaultDelay { get; set; }

    [Parameter]
    public EventCallback<SnackbarClosedEventArgs> Closed { get; set; }

    private SnackbarLocation? _cachedEffectiveLocation;
    private int? _cachedEffectiveDefaultDelay;

    private SnackbarLocation EffectiveLocation
    {
        get
        {
            _cachedEffectiveLocation ??= Location ?? SnackbarLocation.BottomEnd;
            return _cachedEffectiveLocation;
        }
    }

    private int EffectiveDefaultDelay
    {
        get
        {
            _cachedEffectiveDefaultDelay ??= DefaultDelay ?? 5000;
            return _cachedEffectiveDefaultDelay.Value;
        }
    }

    protected override Dictionary<string, object> BuildAttributes() => BuildAttributes(EffectiveLocation);

    protected Dictionary<string, object> BuildAttributes(SnackbarLocation location)
    {
        var attributes = base.BuildAttributes();
        var classes = "q-snackbar-stack snackbar-stack position-fixed p-3";

        classes += location.Value switch
        {
            "top" => " top-0 start-50 translate-middle-x",
            "top-start" => " top-0 start-0",
            "top-end" => " top-0 end-0",
            "bottom" => " bottom-0 start-50 translate-middle-x",
            "bottom-start" => " bottom-0 start-0",
            "bottom-end" => " bottom-0 end-0",
            _ => " bottom-0 end-0"
        };

        EnsureClassAttr(attributes, classes);
        attributes["style"] = "z-index: 1055;";

        return attributes;
    }

    protected override void OnParametersSet()
    {
        _cachedEffectiveLocation = null;
        _cachedEffectiveDefaultDelay = null;
        base.OnParametersSet();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_isInitialized)
        {
            await SnackbarInterop.Initialize();
            _isInitialized = true;
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    public ValueTask Push(string message, CssValue<BackgroundColorBuilder>? color = null, Action<SnackbarOptions>? options = null, SnackbarLocation? location = null) => Push(message, null, color, options, location);

    public ValueTask Push(RenderFragment content, CssValue<BackgroundColorBuilder>? color = null, Action<SnackbarOptions>? options = null, SnackbarLocation? location = null) => Push(null, content, color, options, location);

    private async ValueTask Push(string? message, RenderFragment? content, CssValue<BackgroundColorBuilder>? color, Action<SnackbarOptions>? options, SnackbarLocation? location)
    {
        if (_disposed)
            return;

        var snackbarOptions = new SnackbarOptions();
        options?.Invoke(snackbarOptions);

        var key = snackbarOptions.Key ?? Guid.NewGuid()
                                             .ToString();

        var item = new SnackbarNotificationItem(key, message ?? "", null, color ?? Quark.BackgroundColor.Primary, content, false, null, false, null, snackbarOptions.HideDelay, location);

        _notifications.Add(item);
        await InvokeAsync(StateHasChanged);

        var delay = item.HideDelay ?? EffectiveDefaultDelay;
        if (delay <= 0)
            return;

        // If the same key is reused, dispose the previous timer so we don't leak.
        if (_autoHideTimers.TryGetValue(key, out var existing))
        {
            try
            {
                existing.Stop();
                existing.Dispose();
            }
            catch
            {
            }

            _autoHideTimers.Remove(key);
        }

        var timer = new Timer(delay)
        {
            AutoReset = false,
            Enabled = false
        };

        timer.Elapsed += (_, _) =>
        {
            // Timer thread: never mutate component state here.
            if (_disposed)
                return;

            _ = InvokeAsync(() => HandleClosed(key, SnackbarCloseReason.None));
        };

        _autoHideTimers[key] = timer;
        timer.Start();
    }

    private async Task HandleClosed(string key, SnackbarCloseReason reason)
    {
        if (_disposed)
            return;

        // UI thread (InvokeAsync): safe to mutate collections without locks.
        if (_autoHideTimers.Remove(key, out var timer))
        {
            try
            {
                timer.Stop();
                timer.Dispose();
            }
            catch
            {
            }
        }

        _notifications.RemoveAll(x => x.Key == key);

        await InvokeAsync(StateHasChanged);
        await Closed.InvokeAsync(new SnackbarClosedEventArgs(key, reason));
    }

    public override void Dispose()
    {
        _disposed = true;

        foreach (var timer in _autoHideTimers.Values)
        {
            try
            {
                timer.Stop();
                timer.Dispose();
            }
            catch
            {
            }
        }

        _autoHideTimers.Clear();
        _notifications.Clear();

        base.Dispose();
    }

}