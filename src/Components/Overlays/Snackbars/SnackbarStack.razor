@namespace Soenneker.Quark
@inherits Soenneker.Quark.Element
@using System.Threading
@implements ISnackbarStack
@inject ISnackbarInterop SnackbarInterop

<CascadingValue Name="ParentSnackbar" Value="@this" IsFixed="true">
    @ChildContent

    @foreach (var (location, items) in _byLocation)
    {
        if (items.Count == 0)
            continue;

        <div class="@GetContainerClass(location)" style="z-index: 1055;">
            @foreach (var item in items)
            {
                <Snackbar @key="@item.Key"
                          Key="@item.Key"
                          Visible="@item.Visible"
                          BackgroundColor="@item.Color"
                          AutoHideDelay="@(item.HideDelay ?? EffectiveDefaultDelay)"
                          Closed="OnSnackbarClosed">
                    @if (item.Content != null)
                    {
                        @item.Content
                    }
                    else
                    {
                        @item.Message
                    }
                </Snackbar>
            }
        </div>
    }
</CascadingValue>

@code {
    private readonly List<SnackbarNotificationItem> _notifications = [];

    // Location -> list (so we don't GroupBy every render)
    private readonly Dictionary<SnackbarLocation, List<SnackbarNotificationItem>> _byLocation = new();

    // Key -> location (so close is O(1) to find the right bucket)
    private readonly Dictionary<string, SnackbarLocation> _keyToLocation = new(StringComparer.Ordinal);

    // Key -> CTS (so we can cancel auto-hide)
    private readonly Dictionary<string, CancellationTokenSource> _autoHide = new(StringComparer.Ordinal);

    private bool _isInitialized;
    private bool _disposed;

    [Parameter]
    public SnackbarLocation? Location { get; set; }

    [Parameter]
    public int? DefaultDelay { get; set; }

    [Parameter]
    public EventCallback<SnackbarClosedEventArgs> Closed { get; set; }

    private SnackbarLocation EffectiveLocation => Location ?? SnackbarLocation.BottomEnd;

    private int EffectiveDefaultDelay => DefaultDelay ?? 5000;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_isInitialized)
        {
            await SnackbarInterop.Initialize();
            _isInitialized = true;
        }
    }

    private static string GetContainerClass(SnackbarLocation location)
    {
        const string baseClasses = "q-snackbar-stack snackbar-stack position-fixed p-3";

        return location.Value switch
        {
            "top" => baseClasses + " top-0 start-50 translate-middle-x",
            "top-start" => baseClasses + " top-0 start-0",
            "top-end" => baseClasses + " top-0 end-0",
            "bottom" => baseClasses + " bottom-0 start-50 translate-middle-x",
            "bottom-start" => baseClasses + " bottom-0 start-0",
            "bottom-end" => baseClasses + " bottom-0 end-0",
            _ => baseClasses + " bottom-0 end-0"
        };
    }

    // Non-capturing handler (no per-item closure)
    private Task OnSnackbarClosed(SnackbarClosedEventArgs e) => HandleClosed(e.Key, e.CloseReason);

    public ValueTask Push(string message, CssValue<BackgroundColorBuilder>? color = null, Action<SnackbarOptions>? options = null, SnackbarLocation? location = null) => PushCore(message, null, color, options, location);

    public ValueTask Push(RenderFragment content, CssValue<BackgroundColorBuilder>? color = null, Action<SnackbarOptions>? options = null, SnackbarLocation? location = null) => PushCore(null, content, color, options, location);

    private async ValueTask PushCore(string? message, RenderFragment? content, CssValue<BackgroundColorBuilder>? color, Action<SnackbarOptions>? options, SnackbarLocation? location)
    {
        if (_disposed)
            return;

        var snackbarOptions = new SnackbarOptions();
        options?.Invoke(snackbarOptions);

        var key = snackbarOptions.Key ?? Guid.NewGuid()
                                             .ToString("N");
        var resolvedLocation = location ?? EffectiveLocation;

        _keyToLocation[key] = resolvedLocation;

        var item = new SnackbarNotificationItem(key, message ?? "", null, color ?? Quark.BackgroundColor.Primary, content, false, null, false, null, snackbarOptions.HideDelay, resolvedLocation);

        _notifications.Add(item);

        if (!_byLocation.TryGetValue(resolvedLocation, out var list))
        {
            list = new List<SnackbarNotificationItem>(4);
            _byLocation[resolvedLocation] = list;
        }

        list.Add(item);

        await InvokeAsync(StateHasChanged);

        var delay = item.HideDelay ?? EffectiveDefaultDelay;
        if (delay <= 0)
            return;

        RestartAutoHide(key, delay);
    }

    private void RestartAutoHide(string key, int delayMs)
    {
        if (_autoHide.Remove(key, out var existing))
        {
            existing.Cancel();
            existing.Dispose();
        }

        var cts = new CancellationTokenSource();
        _autoHide[key] = cts;

        _ = AutoHideAsync(key, delayMs, cts.Token);
    }

    private async Task AutoHideAsync(string key, int delayMs, CancellationToken token)
    {
        try
        {
            await Task.Delay(delayMs, token)
                      .ConfigureAwait(false);

            if (token.IsCancellationRequested || _disposed)
                return;

            await InvokeAsync(() => HandleClosed(key, SnackbarCloseReason.None));
        }
        catch (TaskCanceledException)
        {
            // expected
        }
    }

    private async Task HandleClosed(string key, SnackbarCloseReason reason)
    {
        if (_disposed)
            return;

        if (_autoHide.Remove(key, out var cts))
        {
            await cts.CancelAsync();
            cts.Dispose();
        }

        _notifications.RemoveAll(x => x.Key == key);

        if (_keyToLocation.Remove(key, out var loc) && _byLocation.TryGetValue(loc, out var list))
        {
            list.RemoveAll(x => x.Key == key);

            if (list.Count == 0)
                _byLocation.Remove(loc);
        }
        else
        {
            // fallback safety (should be rare)
            foreach (var kvp in _byLocation)
                kvp.Value.RemoveAll(x => x.Key == key);
        }

        await InvokeAsync(StateHasChanged);
        await Closed.InvokeAsync(new SnackbarClosedEventArgs(key, reason));
    }

    public override void Dispose()
    {
        _disposed = true;

        foreach (var cts in _autoHide.Values)
        {
            cts.Cancel();
            cts.Dispose();
        }

        _autoHide.Clear();
        _keyToLocation.Clear();
        _byLocation.Clear();
        _notifications.Clear();

        base.Dispose();
    }

    protected override void ComputeRenderKeyCore(ref HashCode hc)
    {
        hc.Add(Location);
        hc.Add(DefaultDelay);
    }
}