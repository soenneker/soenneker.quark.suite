@using System.Threading
@using Soenneker.Blazor.Extensions.EventCallback
@namespace Soenneker.Quark
@inherits Soenneker.Quark.Element
@implements IOffcanvas
@inject IOffcanvasInterop OffcanvasInterop
@inject IOffcanvasCoordinator OffcanvasCoordinator

<CascadingValue Name="ParentOffcanvas" Value="@this" IsFixed="true">
    <div @attributes="BuildAttributes()">
        @ChildContent
    </div>
    @if (ShowBackdrop && _backdropVisible)
    {
        <div @attributes="BuildBackdropAttributes()" @onclick="HandleBackdropClick"></div>
    }
</CascadingValue>

@code {
    private static readonly TimeSpan _transitionDuration = TimeSpan.FromMilliseconds(350);

    /// <summary>
    /// Gets or sets the placement of the offcanvas.
    /// </summary>
    [Parameter] public PlacementType Placement { get; set; } = PlacementType.End;

    /// <summary>
    /// Gets or sets whether scrolling is allowed when the offcanvas is open.
    /// </summary>
    [Parameter] public bool AllowScroll { get; set; }

    /// <summary>
    /// Gets or sets whether to show the backdrop.
    /// </summary>
    [Parameter] public bool ShowBackdrop { get; set; } = true;

    /// <summary>
    /// Gets or sets the callback invoked when the offcanvas is shown.
    /// </summary>
    [Parameter] public EventCallback OnShow { get; set; }

    /// <summary>
    /// Gets or sets the callback invoked when the offcanvas is hidden.
    /// </summary>
    [Parameter] public EventCallback OnHide { get; set; }

    /// <summary>
    /// Gets or sets the callback invoked when the backdrop is clicked.
    /// </summary>
    [Parameter] public EventCallback OnBackdropClick { get; set; }

    /// <summary>
    /// Gets or sets the tab index of the offcanvas.
    /// </summary>
    [Parameter] public int? TabIndex { get; set; }

    /// <summary>
    /// Gets whether the offcanvas is currently visible.
    /// </summary>
    public bool IsVisible => _active;

    private bool _initialized;
    private bool _active;
    private bool _isShowing;
    private bool _isHiding;
    private bool _backdropVisible;
    private CancellationTokenSource? _transitionCancellation;
    private readonly string _generatedId = $"offcanvas-{Guid.NewGuid():N}";

    protected override void OnInitialized()
    {
        // Offcanvas dialogs should not be in tab order by default
        TabIndex ??= -1;
        
        // Ensure we have a stable id to register with interop
        Id ??= _generatedId;
        // Register this offcanvas with the coordinator so overlay containers can react
        if (!Id.IsNullOrWhiteSpace())
            OffcanvasCoordinator.Register(Id);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_initialized)
        {
            await OffcanvasInterop.Initialize();
            _initialized = true;
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    protected override void BuildAttributesCore(Dictionary<string, object> attributes)
    {
        attributes.TryAdd("data-slot", "sheet");
        // shadcn Sheet - new-york-v4 ui/sheet.tsx
        BuildClassAttribute(attributes, (ref cls) =>
        {
            AppendClass(ref cls, "q-offcanvas");
            AppendClass(ref cls, "fixed inset-y-0 z-50 bg-background shadow-lg transition-transform duration-200 ease-in-out");
            
            switch (Placement.Value)
            {
                case PlacementType.StartValue:
                    AppendClass(ref cls, "q-offcanvas-start");
                    break;
                case PlacementType.EndValue:
                    AppendClass(ref cls, "q-offcanvas-end");
                    break;
                case PlacementType.TopValue:
                    AppendClass(ref cls, "q-offcanvas-top");
                    break;
                case PlacementType.BottomValue:
                    AppendClass(ref cls, "q-offcanvas-bottom");
                    break;
            }
            
            AppendClass(ref cls, "q-offcanvas-shadow");
            
            if (_isShowing)
                AppendClass(ref cls, "q-offcanvas-showing");
            
            if (_active)
                AppendClass(ref cls, "q-offcanvas-show");
            
            if (_isHiding)
                AppendClass(ref cls, "q-offcanvas-hiding");
        });

        // Id and Style are already handled by base.BuildAttributes()

        attributes["role"] = "dialog";
        attributes["aria-modal"] = "true";
    }

    

    private Dictionary<string, object> BuildBackdropAttributes()
    {
        var attributes = new Dictionary<string, object>();
        
        BuildClassAttribute(attributes, (ref cls) =>
        {
            AppendClass(ref cls, "q-offcanvas-backdrop");
            AppendClass(ref cls, "q-offcanvas-fade");
            
            if (_active || _isShowing)
                AppendClass(ref cls, "q-offcanvas-show");
        });
        
        return attributes;
    }

    /// <summary>
    /// Shows the offcanvas.
    /// </summary>
    public async Task Show()
    {
        if (_active || _isShowing)
            return;

        CancellationToken token = StartNewTransition();

        _isHiding = false;
        _isShowing = true;
        _backdropVisible = true;

        await RefreshOffThread();
        await Task.Yield();

        _active = true;
        if (!Id.IsNullOrWhiteSpace())
            OffcanvasCoordinator.Enter(Id);
        await RefreshOffThread();

        await FinalizeTransitionAsync(() =>
        {
            _isShowing = false;
            return Task.CompletedTask;
        }, OnShow, token);
    }

    /// <summary>
    /// Hides the offcanvas.
    /// </summary>
    public async Task Hide()
    {
        if (!_active && !_isShowing)
            return;

        CancellationToken token = StartNewTransition();

        _isShowing = false;
        _isHiding = true;
        _active = false;

        await RefreshOffThread();

        await FinalizeTransitionAsync(async () =>
        {
            _isHiding = false;
            _backdropVisible = false;
            if (!Id.IsNullOrWhiteSpace())
                OffcanvasCoordinator.Exit(Id);
        }, OnHide, token);
    }

    /// <summary>
    /// Requests to close the offcanvas.
    /// </summary>
    /// <returns>A task that represents the asynchronous operation.</returns>
    public Task RequestClose() => Hide();

    private async Task HandleBackdropClick(MouseEventArgs _)
    {
        if (OnBackdropClick.HasDelegate)
            await OnBackdropClick.InvokeAsync();
        await Hide();
    }

    private CancellationToken StartNewTransition()
    {
        CancelActiveTransition();
        _transitionCancellation = new CancellationTokenSource();
        return _transitionCancellation.Token;
    }

    private void CancelActiveTransition()
    {
        if (_transitionCancellation is null)
            return;

        if (!_transitionCancellation.IsCancellationRequested)
        {
            try
            {
                _transitionCancellation.Cancel();
            }
            catch
            {
            }
        }

        _transitionCancellation.Dispose();
        _transitionCancellation = null;
    }

    private void ClearTransitionCancellation()
    {
        if (_transitionCancellation is null)
            return;

        _transitionCancellation.Dispose();
        _transitionCancellation = null;
    }

    private async Task FinalizeTransitionAsync(Func<Task> transitionComplete, EventCallback callback, CancellationToken token)
    {
        try
        {
            await Task.Delay(_transitionDuration, token);
        }
        catch (TaskCanceledException)
        {
            return;
        }

        ClearTransitionCancellation();

        await transitionComplete();
        await RefreshOffThread();

        await callback.InvokeIfHasDelegate();
    }

    public override async ValueTask DisposeAsync()
    {
        try
        {
            if (_initialized && Id.HasContent())
            {
                // Ensure global overlay count is balanced if component is torn down while open
                if (!_backdropVisible && _active) _active = false;
                // Unregister from coordinator
                OffcanvasCoordinator.Unregister(Id);
            }
        }
        catch
        {
            /* ignore */
        }

        CancelActiveTransition();
    }

    protected override void ComputeRenderKeyCore(ref HashCode hc)
    {
        hc.Add(Placement);
        hc.Add(AllowScroll);
        hc.Add(ShowBackdrop);
        hc.Add(TabIndex);
    }
}