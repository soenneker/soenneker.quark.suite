@using System.Threading
@using Soenneker.Blazor.Extensions.EventCallback
@namespace Soenneker.Quark
@inherits Soenneker.Quark.Element
@implements IOffcanvas
@inject IOffcanvasInterop OffcanvasInterop
@inject IOffcanvasCoordinator OffcanvasCoordinator

<CascadingValue Value="@this" IsFixed="true">
    <Div @attributes="BuildAttributes()">
        @ChildContent
    </Div>
    @if (ShowBackdrop && _backdropVisible)
    {
        <Div @attributes="BuildBackdropAttributes()" OnClick="HandleBackdropClick"></Div>
    }
</CascadingValue>

@code {
    public override string? ThemeKey { get; set; } = "Offcanvas";

    private static readonly TimeSpan _transitionDuration = TimeSpan.FromMilliseconds(350);

    [Parameter] public PlacementType Placement { get; set; } = PlacementType.End;

    [Parameter] public bool AllowScroll { get; set; }

    [Parameter] public bool ShowBackdrop { get; set; } = true;

    [Parameter] public EventCallback OnShow { get; set; }

    [Parameter] public EventCallback OnHide { get; set; }

    [Parameter] public EventCallback OnBackdropClick { get; set; }

    /// <summary>
    /// Gets whether the offcanvas is currently visible.
    /// </summary>
    public bool IsVisible => _active;

    private bool _initialized;
    private bool _active;
    private bool _isShowing;
    private bool _isHiding;
    private bool _backdropVisible;
    private CancellationTokenSource? _transitionCancellation;
    private readonly string _generatedId = $"offcanvas-{Guid.NewGuid():N}";

    protected override void OnInitialized()
    {
        // Offcanvas dialogs should not be in tab order by default
        TabIndex ??= -1;
        
        // Ensure we have a stable id to register with interop
        Id ??= _generatedId;
        // Register this offcanvas with the coordinator so overlay containers can react
        if (!Id.IsNullOrWhiteSpace())
            OffcanvasCoordinator.Register(Id);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_initialized)
        {
            await OffcanvasInterop.Initialize();
            _initialized = true;
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    protected override Dictionary<string, object> BuildAttributes()
    {
        var attributes = base.BuildAttributes();

        BuildClassAttribute(attributes, (ref PooledStringBuilder cls) =>
        {
            AppendClass(ref cls, "offcanvas");
            
            switch (Placement.Value)
            {
                case PlacementType.StartValue:
                    AppendClass(ref cls, "offcanvas-start");
                    break;
                case PlacementType.EndValue:
                    AppendClass(ref cls, "offcanvas-end");
                    break;
                case PlacementType.TopValue:
                    AppendClass(ref cls, "offcanvas-top");
                    break;
                case PlacementType.BottomValue:
                    AppendClass(ref cls, "offcanvas-bottom");
                    break;
            }
            
            AppendClass(ref cls, "quark-offcanvas");
            AppendClass(ref cls, "quark-offcanvas-shadow");
            
            if (_isShowing)
                AppendClass(ref cls, "showing");
            
            if (_active)
                AppendClass(ref cls, "show");
            
            if (_isHiding)
                AppendClass(ref cls, "hiding");
        });

        attributes["id"] = Id;
        
        if (Style.HasContent())
            attributes["style"] = Style;

        attributes["role"] = "dialog";
        attributes["aria-modal"] = "true";

        return attributes;
    }

    private Dictionary<string, object> BuildBackdropAttributes()
    {
        var attributes = new Dictionary<string, object>();
        
        BuildClassAttribute(attributes, (ref PooledStringBuilder cls) =>
        {
            AppendClass(ref cls, "offcanvas-backdrop");
            AppendClass(ref cls, "fade");
            
            if (_active || _isShowing)
                AppendClass(ref cls, "show");
        });
        
        return attributes;
    }

    public async Task Show()
    {
        if (_active || _isShowing)
            return;

        var token = StartNewTransition();

        _isHiding = false;
        _isShowing = true;
        _backdropVisible = true;

        await InvokeAsync(StateHasChanged);
        await Task.Yield();

        _active = true;
        if (!Id.IsNullOrWhiteSpace())
            OffcanvasCoordinator.Enter(Id);
        await InvokeAsync(StateHasChanged);

        await FinalizeTransitionAsync(() =>
        {
            _isShowing = false;
            return Task.CompletedTask;
        }, OnShow, token);
    }

    public async Task Hide()
    {
        if (!_active && !_isShowing)
            return;

        var token = StartNewTransition();

        _isShowing = false;
        _isHiding = true;
        _active = false;

        await InvokeAsync(StateHasChanged);

        await FinalizeTransitionAsync(async () =>
        {
            _isHiding = false;
            _backdropVisible = false;
            if (!Id.IsNullOrWhiteSpace())
                OffcanvasCoordinator.Exit(Id);
        }, OnHide, token);
    }

    public Task RequestClose() => Hide();

    private async Task HandleBackdropClick(MouseEventArgs _)
    {
        if (OnBackdropClick.HasDelegate)
            await OnBackdropClick.InvokeAsync();
        await Hide();
    }

    private CancellationToken StartNewTransition()
    {
        CancelActiveTransition();
        _transitionCancellation = new CancellationTokenSource();
        return _transitionCancellation.Token;
    }

    private void CancelActiveTransition()
    {
        if (_transitionCancellation is null)
            return;

        if (!_transitionCancellation.IsCancellationRequested)
        {
            try
            {
                _transitionCancellation.Cancel();
            }
            catch
            {
            }
        }

        _transitionCancellation.Dispose();
        _transitionCancellation = null;
    }

    private void ClearTransitionCancellation()
    {
        if (_transitionCancellation is null)
            return;

        _transitionCancellation.Dispose();
        _transitionCancellation = null;
    }

    private async Task FinalizeTransitionAsync(Func<Task> transitionComplete, EventCallback callback, CancellationToken token)
    {
        try
        {
            await Task.Delay(_transitionDuration, token);
        }
        catch (TaskCanceledException)
        {
            return;
        }

        ClearTransitionCancellation();

        await InvokeAsync(async () =>
        {
            await transitionComplete();
            StateHasChanged();
        });

        await callback.InvokeIfHasDelegate();
    }

    public override async ValueTask DisposeAsync()
    {
        try
        {
            if (_initialized && Id.HasContent())
            {
                // Ensure global overlay count is balanced if component is torn down while open
                if (!_backdropVisible && _active) _active = false;
                // Unregister from coordinator
                OffcanvasCoordinator.Unregister(Id);
            }
        }
        catch
        {
            /* ignore */
        }

        CancelActiveTransition();
    }

}