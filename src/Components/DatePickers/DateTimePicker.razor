@using System.Globalization
@using System.Linq.Expressions
@using Microsoft.JSInterop
@using Soenneker.Blazor.Extensions.EventCallback
@using Soenneker.Utils.PooledStringBuilders

@namespace Soenneker.Quark
@inherits Soenneker.Quark.Element
@implements Soenneker.Quark.IValidationInput
@implements IDateTimePicker
@inject IDatePickerInterop DatePickerInterop

<Div OnElementRefReady="HandleContainerRefReady" @attributes="GetContainerAttributes()">
    <input @ref="_ref" type="text" @attributes="BuildAttributes()" />

    @if (_open)
    {
        <div class="quark-date-backdrop" style="position: fixed; inset: 0; z-index: 1075;" @onclick="ClosePanel"></div>
        <Div @attributes="BuildPanelAttributes()" @onclick:stopPropagation="true">
            <div class="qcal-header d-flex align-items-center justify-content-between">
                <button type="button" class="btn btn-sm btn-light qcal-nav" @onclick="PrevMonth">‹</button>
                <div class="qcal-title fw-semibold">@_displayMonth.ToString("MMMM yyyy", CultureInfo.CurrentUICulture)</div>
                <button type="button" class="btn btn-sm btn-light qcal-nav" @onclick="NextMonth">›</button>
            </div>
            <div class="qcal-grid mt-2">
                @foreach (var dow in _dayNames)
                {
                    <div class="qcal-dow text-muted">@dow</div>
                }
                @foreach (var day in BuildMonthCells())
                {
                    var css = day.InMonth ? "qcal-day" : "qcal-day text-muted";
                    if (day.Date == DateOnly.FromDateTime(DateTime.Today))
                    {
                        css += " qcal-today";
                    }
                    if (Value.HasValue && day.Date == DateOnly.FromDateTime(Value.Value))
                    {
                        css += " qcal-selected";
                    }
                    if (day.Disabled)
                    {
                        css += " disabled";
                    }

                    <button type="button" class="@css" disabled="@day.Disabled" @onclick="(() => SelectDate(day.Date))">@day.Date.Day</button>
                }
            </div>

            <div class="qcal-time qcal-time-full">
                <div class="qnum-wrapper">
                    <input class="qnum-input qnum-hour" type="number" aria-label="Hour" step="1" min="1" max="12" value="@DisplayHour"
                           @oninput="OnHourInput" @onwheel="OnHourWheel" @onkeydown="OnHourKeyDown" />
                    <span class="qnum-arrowUp" @onclick="IncrementHour"></span>
                    <span class="qnum-arrowDown" @onclick="DecrementHour"></span>
                </div>
                <span class="qcal-time-separator">:</span>
                <div class="qnum-wrapper">
                    <input class="qnum-input qnum-minute" type="number" aria-label="Minute" step="@MinuteStep" min="0" max="59" value="@_minute"
                           @oninput="OnMinuteInput" @onwheel="OnMinuteWheel" @onkeydown="OnMinuteKeyDown" />
                    <span class="qnum-arrowUp" @onclick="IncrementMinute"></span>
                    <span class="qnum-arrowDown" @onclick="DecrementMinute"></span>
                </div>
                <div class="qcal-time-ampm">
                    <button type="button" class="qcal-time-ampm-toggle" title="Click to toggle" @onclick="ToggleAmPm">@(_isAm ? "AM" : "PM")</button>
                </div>
            </div>
        </Div>
    }
</Div>

@code {
    public override string? ThemeKey { get; set; } = "DateTimePicker";

    [Parameter]
    public DateTime? Value { get; set; }

    [Parameter]
    public Expression<Func<DateTime?>>? ValueExpression { get; set; }

    [Parameter]
    public string? Placeholder { get; set; }

    [Parameter]
    public bool Disabled { get; set; }

    [Parameter]
    public bool ReadOnly { get; set; }

    [Parameter]
    public bool Required { get; set; }

    [Parameter]
    public DateTime? Min { get; set; }

    [Parameter]
    public DateTime? Max { get; set; }


    [Parameter]
    public CssValue<SizeBuilder>? Size { get; set; } = Quark.Size.Default;

    [Parameter]
    public EventCallback<DateTime?> ValueChanged { get; set; }

    [Parameter]
    public EventCallback<ChangeEventArgs> OnChange { get; set; }

    [Parameter]
    public EventCallback<ChangeEventArgs> OnInput { get; set; }

    [CascadingParameter]
    public Validation? ParentValidation { get; set; }

    public object? ValidationValue => Value;

    private ElementReference _ref;
    private ElementReference _containerRef;
    private DotNetObjectReference<DateTimePickerOutsideCloseProxy>? _outsideRef;
    private bool _open;
    private DateOnly _displayMonth = DateOnly.FromDateTime(DateTime.Today);
    private string[] _dayNames = [];
    private DateOnly? _pendingDate;
    private int _hour; // 0-23
    private int _minute; // 0-59
    private bool _isAm;
    private const int MinuteStep = 1;

    private static DateTime? Parse(ChangeEventArgs e)
    {
        if (e?.Value == null)
            return null;

        var text = e.Value.ToString();
        // Accept common formats (with T or space)
        if (text.IsNullOrWhiteSpace())
            return null;

        var normalized = text.Trim();
        if (normalized.Contains(' ') && !normalized.Contains('T'))
            normalized = normalized.Replace(' ', 'T');

        if (DateTime.TryParse(normalized, CultureInfo.InvariantCulture, DateTimeStyles.AssumeLocal, out var result))
            return result;

        return null;
    }

    private async Task HandleInput(ChangeEventArgs e)
    {
        Value = Parse(e);
        await ValueChanged.InvokeIfHasDelegate(Value);
        await OnInput.InvokeIfHasDelegate(e);

        if (ParentValidation is not null)
            await ParentValidation.NotifyInputChanged(Value);
    }

    private async Task HandleChange(ChangeEventArgs e)
    {
        Value = Parse(e);
        await ValueChanged.InvokeIfHasDelegate(Value);
        await OnChange.InvokeIfHasDelegate(e);

        if (ParentValidation is not null)
            await ParentValidation.NotifyInputChanged(Value);
    }

    private string? GetSizeClass()
    {
        if (Size == Quark.Size.Default)
            return null;

        string? token = null;
        var isTheme = Size?.TryGetBootstrapThemeToken(out token) == true;
        if (isTheme && token is not null)
            return $"form-control-{token}";

        return Size?.ToString() != null ? $"form-control-{Size}" : null;
    }


    private string? GetValidationClass()
    {
        if (ParentValidation?.Status == ValidationStatus.Error)
            return "is-invalid";

        if (ParentValidation?.Status == ValidationStatus.Success)
            return "is-valid";

        return null;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && ParentValidation is not null)
        {
            await ParentValidation.InitializeInput(this);

            if (ValueExpression is not null)
            {
                await ParentValidation.InitializeInputExpression(ValueExpression);
            }
        }

        if (firstRender)
        {
            await DatePickerInterop.Initialize();
            await DatePickerInterop.Attach(_ref);
            _outsideRef = DotNetObjectReference.Create(new DateTimePickerOutsideCloseProxy(this));
            await DatePickerInterop.RegisterOutsideClose(_containerRef, _outsideRef, nameof(DateTimePickerOutsideCloseProxy.Close));
            InitializeDayNames();
            if (Value.HasValue)
            {
                _displayMonth = DateOnly.FromDateTime(Value.Value);
                _hour = Value.Value.Hour;
                _minute = Value.Value.Minute;
            }
            else
            {
                _displayMonth = DateOnly.FromDateTime(DateTime.Today);
                var now = DateTime.Now;
                _hour = now.Hour;
                _minute = now.Minute;
            }

            _isAm = _hour < 12;
            StateHasChanged();
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    private static string FormatDisplay(DateTime dt) => dt.ToString("yyyy-MM-dd HH:mm", CultureInfo.InvariantCulture);
    private int DisplayHour => ((_hour % 12) == 0) ? 12 : (_hour % 12);

    protected override Dictionary<string, object> BuildAttributes()
    {
        var attributes = base.BuildAttributes();

        var baseClasses = "form-control quark-datepicker quark-datepicker--icon";
        var sizeClass = GetSizeClass();
        var validationClass = GetValidationClass();

        if (sizeClass != null)
            baseClasses = $"{baseClasses} {sizeClass}";
        if (validationClass != null)
            baseClasses = $"{baseClasses} {validationClass}";

        AppendToClassAttr(attributes, baseClasses);

        if (Value.HasValue)
            attributes["value"] = FormatDisplay(Value.Value);

        if (Placeholder.HasContent())
            attributes["placeholder"] = Placeholder!;

        if (Disabled)
            attributes["disabled"] = true;

        if (ReadOnly)
            attributes["readonly"] = true;

        if (Required)
            attributes["required"] = true;

        // min/max intentionally omitted for text input (handled in panel)

        attributes["onclick"] = EventCallback.Factory.Create<MouseEventArgs>(this, OpenPanel);
        attributes["onfocus"] = EventCallback.Factory.Create<FocusEventArgs>(this, OpenPanel);

        attributes["autocomplete"] = "off";
        attributes["oninput"] = EventCallback.Factory.Create<ChangeEventArgs>(this, HandleInput);
        attributes["onchange"] = EventCallback.Factory.Create<ChangeEventArgs>(this, HandleChange);

        return attributes;
    }

    private Task HandleContainerRefReady(ElementReference el)
    {
        _containerRef = el;
        return Task.CompletedTask;
    }

    private Dictionary<string, object> GetContainerAttributes()
    {
        var attrs = new Dictionary<string, object>(2);
        AppendToClassAttr(attrs, "position-relative d-inline-block quark-date-container");
        return attrs;
    }

    private Dictionary<string, object> BuildPanelAttributes()
    {
        var attrs = new Dictionary<string, object>(4);
        AppendToClassAttr(attrs, "quark-calendar-panel shadow-lg border rounded-3 bg-white p-3");
        attrs["style"] = "position: absolute; top: calc(100% + .25rem); left: 0; z-index: 1080; min-width: 18rem;";
        return attrs;
    }

    private void InitializeDayNames()
    {
        var culture = CultureInfo.CurrentCulture;
        var first = culture.DateTimeFormat.FirstDayOfWeek;
        var names = culture.DateTimeFormat.AbbreviatedDayNames;
        _dayNames = Enumerable.Range(0, 7)
            .Select(i => names[((int)first + i) % 7])
            .ToArray();
    }

    private readonly record struct Cell(DateOnly Date, bool InMonth, bool Disabled);

    private IEnumerable<Cell> BuildMonthCells()
    {
        var firstOfMonth = new DateOnly(_displayMonth.Year, _displayMonth.Month, 1);
        var culture = CultureInfo.CurrentCulture;
        var startDow = culture.DateTimeFormat.FirstDayOfWeek;
        var offset = ((int)firstOfMonth.DayOfWeek - (int)startDow + 7) % 7;
        var gridStart = firstOfMonth.AddDays(-offset);

        for (var i = 0; i < 42; i++)
        {
            var d = gridStart.AddDays(i);
            var inMonth = d.Month == _displayMonth.Month;
            var disabled = (Min.HasValue && d < DateOnly.FromDateTime(Min.Value)) || (Max.HasValue && d > DateOnly.FromDateTime(Max.Value));
            yield return new Cell(d, inMonth, disabled);
        }
    }

    private Task OpenPanel()
    {
        if (!_open)
            _open = true;
        return InvokeAsync(StateHasChanged);
    }

    internal Task ClosePanel()
    {
        if (_open)
            _open = false;
        return InvokeAsync(StateHasChanged);
    }


    private Task Commit()
    {
        var date = _pendingDate ?? (Value.HasValue ? DateOnly.FromDateTime(Value.Value) : DateOnly.FromDateTime(DateTime.Today));
        var dt = new DateTime(date.Year, date.Month, date.Day, _hour, _minute, 0);
        Value = dt;
        return InvokeAsync(async () =>
        {
            await ValueChanged.InvokeIfHasDelegate(Value);
            if (ParentValidation is not null)
                await ParentValidation.NotifyInputChanged(Value);
        });
    }

    private async Task SelectDate(DateOnly date)
    {
        if ((Min.HasValue && date < DateOnly.FromDateTime(Min.Value)) || (Max.HasValue && date > DateOnly.FromDateTime(Max.Value)))
            return;

        _pendingDate = date;
        await Commit();
    }

    private Task IncrementHour() { _hour = (_hour + 1) % 24; _isAm = _hour < 12; return Commit(); }
    private Task DecrementHour() { _hour = (_hour + 23) % 24; _isAm = _hour < 12; return Commit(); }
    private Task IncrementMinute() { _minute = (_minute + MinuteStep) % 60; return Commit(); }
    private Task DecrementMinute() { _minute = (_minute + 60 - MinuteStep) % 60; return Commit(); }
    private Task SetAmPm(bool am) { _isAm = am; if (am && _hour >= 12) _hour -= 12; if (!am && _hour < 12) _hour += 12; return Commit(); }
    private Task ToggleAmPm() => SetAmPm(!_isAm);
    private Task OnHourWheel(WheelEventArgs e) => (e.DeltaY < 0) ? IncrementHour() : DecrementHour();
    private Task OnMinuteWheel(WheelEventArgs e) => (e.DeltaY < 0) ? IncrementMinute() : DecrementMinute();

    private Task OnHourKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "ArrowUp") return IncrementHour();
        if (e.Key == "ArrowDown") return DecrementHour();
        return Task.CompletedTask;
    }

    private Task OnMinuteKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "ArrowUp") return IncrementMinute();
        if (e.Key == "ArrowDown") return DecrementMinute();
        return Task.CompletedTask;
    }

    private Task OnHourInput(ChangeEventArgs e)
    {
        if (e?.Value is null) return Task.CompletedTask;
        if (int.TryParse(e.Value.ToString(), out var v))
        {
            v = Math.Clamp(v, 1, 12);
            // preserve am/pm while mapping 12->0 for AM case
            var baseHour = _isAm ? 0 : 12;
            _hour = (v % 12) + baseHour;
            return Commit();
        }
        return Task.CompletedTask;
    }

    private Task OnMinuteInput(ChangeEventArgs e)
    {
        if (e?.Value is null) return Task.CompletedTask;
        if (int.TryParse(e.Value.ToString(), out var v))
        {
            v = ((v % 60) + 60) % 60;
            _minute = v;
            return Commit();
        }
        return Task.CompletedTask;
    }

    private Task PrevMonth()
    {
        _displayMonth = _displayMonth.AddMonths(-1);
        return InvokeAsync(StateHasChanged);
    }

    private Task NextMonth()
    {
        _displayMonth = _displayMonth.AddMonths(1);
        return InvokeAsync(StateHasChanged);
    }

    protected override Task OnDisposeAsync()
    {
        _outsideRef?.Dispose();
        return Task.CompletedTask;
    }

    protected override void ApplyBackgroundColor(ref PooledStringBuilder sty, ref PooledStringBuilder cls)
    {
        if (BackgroundColor is { IsEmpty: false })
        {
            string? token = null;
            var isTheme = BackgroundColor.Value.TryGetBootstrapThemeToken(out token);

            if (isTheme && token is not null)
            {
                AppendClass(ref cls, $"form-control-{token}");
            }
            else
            {
                var result = BackgroundColor.ToString();
                if (!result.HasContent()) return;

                if (BackgroundColor.Value.IsCssStyle)
                    AppendStyleDecl(ref sty, $"background-color: {result}");
                else
                    AppendClass(ref cls, $"form-control-{result}");
            }
        }
    }
}


