@using System.Runtime.CompilerServices
@using Soenneker.Extensions.String

@namespace Soenneker.Quark
@inherits Soenneker.Quark.Element
@implements IButton
@inject NavigationManager Navigation

@if (Type == ButtonType.Link)
{
	<Anchor To="To" Attributes="BuildAttributes()" >
		@ChildContent
	</Anchor>
}
else
{
    <button @onclick="HandleClick" @attributes="BuildAttributes()">
		@if (Loading)
		{
			<Span Class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true" ></Span>
		}
		@if (LoadingTemplate is not null && Loading)
		{
			@LoadingTemplate
		}
		else
		{
			@ChildContent
		}
	</button>
}

@code {

	public override string? ThemeKey { get; set; } = "Button";

    [Parameter]
	public ButtonType Type { get; set; } = ButtonType.Button;

	[Parameter]
	public bool Disabled { get; set; }

	[Parameter]
	public bool Loading { get; set; }

	[Parameter]
	public RenderFragment? LoadingTemplate { get; set; }

	[Parameter]
	public string? Value { get; set; }

	[Parameter]
	public string? Form { get; set; }

	[Parameter]
	public bool AutoFocus { get; set; }

	[Parameter]
	public string? To { get; set; }

	[Parameter]
	public string? Name { get; set; }

	[Parameter]
	public CssValue<SizeBuilder>? Size { get; set; } = Quark.Size.Default;

	[Parameter]
	public CssValue<ColorBuilder>? Color { get; set; }

	[Parameter]
	public bool Outline { get; set; }

	[Parameter]
	public bool Block { get; set; }

	[Parameter]
	public bool Close { get; set; }

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private string? GetSizeClass() 
	{
		if (Size == Quark.Size.Default)
			return null;

		string? token = null;
		var isTheme = Size?.TryGetBootstrapThemeToken(out token) == true;

		if (isTheme && token is not null)
			return $"btn-{token}";

		// SizeBuilder now generates clean tokens like "lg", "sm" without prefix
		var sizeValue = Size?.ToString();
		return sizeValue.HasContent() ? $"btn-{sizeValue}" : null;
	}

	protected override Dictionary<string, object> BuildAttributes()
	{
		var attributes = base.BuildAttributes();

		// Determine element kind
		var isLink = Type == ButtonType.Link || To.HasContent();

		// Figure out disabled state (treat presence of "disabled" attribute as true)
		var isDisabled = Disabled || Loading || attributes.ContainsKey("disabled");

		// Add Bootstrap button classes
		if (Close)
		{
			AppendToClassAttr(attributes, "btn-close");
		}
		else
		{
			AppendToClassAttr(attributes, "btn");
		}

		string? colorToken = null;
		var isColorTheme = Color?.TryGetBootstrapThemeToken(out colorToken) == true;

        if (Color is not null && !Color.Value.IsEmpty && !Close)
        {
            var v = Color.Value.ToString().Trim();

            if (isColorTheme && colorToken is not null)
            {
                // Bootstrap theme token (e.g., "primary", "secondary")
				var prefix = Outline ? "btn-outline-" : "btn-";
				AppendToClassAttr(attributes, $"{prefix}{colorToken}");
            }
            else if (Color.Value.IsCssClass)
            {
                if (v.StartsWith("btn-", StringComparison.Ordinal))
					AppendToClassAttr(attributes, v);
                else
				{
					var prefix = Outline ? "btn-outline-" : "btn-";
					AppendToClassAttr(attributes, $"{prefix}{v}");
				}
            }
            else
            {
                // Build style efficiently
                var styleParts = new List<string> { $"background-color:{v}", $"border-color:{v}" };
                
				if (attributes.TryGetValue("style", out var existing) && existing?.ToString().HasContent() == true)
                    styleParts.Insert(0, existing.ToString()!);
                    
				attributes["style"] = string.Join(";", styleParts) + ";";
            }
        }

		// Add size class if not default
		var sizeClass = GetSizeClass();

		if (sizeClass is not null)
			AppendToClassAttr(attributes, sizeClass);

		// Add block class if needed
		if (Block)
			AppendToClassAttr(attributes, "btn-block");

		// Apply disabled visuals for anchor-style buttons
		if (isLink && isDisabled)
			AppendToClassAttr(attributes, "disabled");

		// Common ARIA for loading/disabled
		if (Loading)
            attributes["aria-busy"] = "true";

		// Only set type on real <button>
		if (!isLink)
            attributes["type"] = Type.Value;

		// Real disabled vs. aria-disabled
		if (isLink)
		{
			// Anchor can't be truly disabled; use ARIA and remove focus
			if (isDisabled)
			{
                attributes["aria-disabled"] = "true";
                attributes["tabindex"] = "-1";
				// role is already a good idea for link-as-button
                attributes["role"] = "button";
			}
			else
                attributes.TryAdd("role", "button");
		}
		else
		{
			if (isDisabled)
                attributes["disabled"] = true;
		}

		// Standard button/submit metadata
		if (Value.HasContent()) attributes["value"] = Value!;
		if (Name.HasContent()) attributes["name"] = Name!;
		if (Form.HasContent()) attributes["form"] = Form!;
		if (AutoFocus) attributes["autofocus"] = true;
		if (AriaLabel.HasContent()) attributes["aria-label"] = AriaLabel!;

		// If this is acting as a link, we already render <Anchor>; nothing special beyond attrs.
		return attributes;
	}

	protected override async Task HandleClick(MouseEventArgs args)
	{
		// Respect disabled state at runtime, same semantics as in BuildAttributes
		var isDisabled = Disabled || Loading || (Attributes is not null && Attributes.ContainsKey("disabled"));
		if (isDisabled)
			return;

		// Programmatic navigation if To is set (and not a hash)
		if (To.HasContent() && !To!.StartsWith("#"))
			Navigation.NavigateTo(To!);

		await base.HandleClick(args);
	}

}
