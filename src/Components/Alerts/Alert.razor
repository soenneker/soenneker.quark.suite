@using Soenneker.Blazor.Extensions.EventCallback
@using Soenneker.Extensions.String

@namespace Soenneker.Quark
@inherits Soenneker.Quark.Element
@implements IAlert

<CascadingValue Value="@this" IsFixed>
    <Div Class="alert" @attributes="BuildAttributes()" role="alert" >
        @if (Dismissible)
        {
            <Button Type="@ButtonType.Button" Class="btn-close" OnClick="HandleDismiss" aria-label="Close" ></Button>
        }
        @ChildContent
    </Div>
</CascadingValue>

@code {
	public override string? ThemeKey { get; set; } = "Alert";

    // Internal state tracking for child components
    private bool _hasMessage;
    private bool _hasDescription;

    [Parameter]
    public CssValue<ColorBuilder>? Color { get; set; }

    [Parameter]
    public CssValue<AlertStyleBuilder>? AlertStyle { get; set; }


    [Parameter]
    public bool Dismissible { get; set; }

    [Parameter]
    public bool Visible { get; set; } = true;

    [Parameter]
    public EventCallback<bool> VisibleChanged { get; set; }

    [Parameter]
    public EventCallback OnDismiss { get; set; }
    
    protected override Dictionary<string, object> BuildAttributes()
    {
        var attributes = base.BuildAttributes();

        AppendToClassAttr(attributes, "alert");


        if (Dismissible)
        {
            AppendToClassAttr(attributes, "alert-dismissible");
            AppendToClassAttr(attributes, "fade");
            
            if (Visible)
                AppendToClassAttr(attributes, "show");
        }

        // Add classes for child component detection
        if (_hasMessage)
            AppendToClassAttr(attributes, "alert-has-message");

        if (_hasDescription)
            AppendToClassAttr(attributes, "alert-has-description");

        // Handle alert styling
        if (AlertStyle is not null && !AlertStyle.Value.IsEmpty)
        {
            var alertClass = AlertStyle.Value.ToString();
            if (alertClass.HasContent())
            {
                AppendToClassAttr(attributes, alertClass);
            }
        }

        // Handle color styling
        if (Color is not null && !Color.Value.IsEmpty)
        {
            var v = Color.Value.ToString().Trim();

            if (Color.Value.IsCssClass)
            {
                if (v.StartsWith("alert-", StringComparison.Ordinal))
                    AppendToClassAttr(attributes, v);
                else
                    AppendToClassAttr(attributes, $"alert-{v}");
            }
            else
            {
                // Build style efficiently
                var styleParts = new List<string> { $"background-color:{v}", $"border-color:{v}", "color:white" };
                
                if (attributes.TryGetValue("style", out var existing) && existing?.ToString().HasContent() == true)
                    styleParts.Insert(0, existing.ToString()!);
                    
                attributes["style"] = string.Join(";", styleParts) + ";";
            }
        }

        if (!Visible)
        {
            if (attributes.TryGetValue("style", out var existingStyle) && existingStyle?.ToString().HasContent() == true)
                attributes["style"] = $"{existingStyle}display: none;";
            else
                attributes["style"] = "display: none;";
        }

        return attributes;
    }

    public Task Show()
    {
        if (Visible)
            return Task.CompletedTask;

        Visible = true;
        return InvokeAsync(StateHasChanged);
    }

    public Task Hide()
    {
        if (!Visible)
            return Task.CompletedTask;

        Visible = false;
        return InvokeAsync(StateHasChanged);
    }

    public Task Toggle()
    {
        Visible = !Visible;
        return InvokeAsync(StateHasChanged);
    }
    
    internal void NotifyHasMessage()
    {
        _hasMessage = true;
        InvokeAsync(StateHasChanged);
    }

    internal void NotifyHasDescription()
    {
        _hasDescription = true;
        InvokeAsync(StateHasChanged);
    }


    private async Task HandleDismiss()
    {
        Visible = false;
        StateHasChanged();

        await OnDismiss.InvokeIfHasDelegate();
        await VisibleChanged.InvokeAsync(Visible);
    }

}
