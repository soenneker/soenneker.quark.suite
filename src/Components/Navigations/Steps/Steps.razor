@namespace Soenneker.Quark
@inherits Soenneker.Quark.Element
@using Microsoft.AspNetCore.Components.Routing
@using Soenneker.Blazor.Extensions.EventCallback
@implements ISteps
@inject IStepsInterop StepsInterop
@inject NavigationManager Navigation

<CascadingValue Value="_state">
    <CascadingValue Value="this">
        <div Class="steps-container">
            <ul @attributes="BuildAttributes()">
                @if (Items != null)
                {
                    @Items
                }
                else
                {
                    @ChildContent
                }
            </ul>
        </div>
    </CascadingValue>
</CascadingValue>

@code {
    private StepsState _state = new();
    private readonly List<string> _stepItems = [];
    private readonly List<string> _stepPanels = [];
    private bool _navigationSubscribed;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await StepsInterop.Initialize();

            // Sync initial selection from URL fragment if present
            var fragment = GetFragment();
            if (fragment.HasContent() && _stepItems.Contains(fragment) && fragment != _state.SelectedStep)
            {
                _state = _state with { SelectedStep = fragment };
                AriaDescribedBy = _state.SelectedStep;

                await SelectedStepChanged.InvokeIfHasDelegate(_state.SelectedStep);
                StateHasChanged();
            }

            // Subscribe to fragment changes
            if (!_navigationSubscribed)
            {
                Navigation.LocationChanged += HandleLocationChanged;
                _navigationSubscribed = true;
            }
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    /// <summary>
    /// Gets or sets the aria-describedby attribute value.
    /// </summary>
    [Parameter]
    public string? AriaDescribedBy { get; set; }

    /// <summary>
    /// Gets or sets the currently selected step.
    /// </summary>
    [Parameter]
    public string SelectedStep
    {
        get => _state.SelectedStep;
        set
        {
            if (value == _state.SelectedStep)
                return;

            var allowNavigation = NavigationAllowed?.Invoke(new StepNavigationContext
            {
                CurrentStepName = _state.SelectedStep,
                CurrentStepIndex = IndexOfStep(_state.SelectedStep),
                NextStepName = value,
                NextStepIndex = IndexOfStep(value),
            }) ?? true;

            if (allowNavigation == false)
                return;

            _state = _state with { SelectedStep = value };
            // Nudge render key so this component re-renders and cascades the new state
            AriaDescribedBy = _state.SelectedStep;
            SelectedStepChanged.InvokeAsync(_state.SelectedStep);
            StateHasChanged();
        }
    }

    /// <summary>
    /// Gets or sets the render mode for the steps.
    /// </summary>
    [Parameter]
    public StepsRenderMode RenderMode
    {
        get => _state.RenderMode;
        set
        {
            _state = _state with { RenderMode = value };
            StateHasChanged();
        }
    }

    /// <summary>
    /// Gets or sets the callback invoked when the selected step changes.
    /// </summary>
    [Parameter]
    public EventCallback<string> SelectedStepChanged { get; set; }

    /// <summary>
    /// Gets or sets the function that determines whether navigation to a step is allowed.
    /// </summary>
    [Parameter]
    public Func<StepNavigationContext, bool>? NavigationAllowed { get; set; }

    /// <summary>
    /// Gets or sets the render fragment for step items.
    /// </summary>
    [Parameter]
    public RenderFragment? Items { get; set; }

    /// <summary>
    /// Notifies that a step has been initialized.
    /// </summary>
    /// <param name="name">The name of the step.</param>
    internal void NotifyStepInitialized(string name)
    {
        if (!_stepItems.Contains(name))
        {
            _stepItems.Add(name);

            // Set initial selected step if not already set
            if (string.IsNullOrEmpty(_state.SelectedStep))
            {
                var fragment = GetFragment();
                var initial = fragment.HasContent() && _stepItems.Contains(fragment) ? fragment : name;
                _state = _state with { SelectedStep = initial };
                AriaDescribedBy = _state.SelectedStep;
                StateHasChanged();
            }
        }
    }

    /// <summary>
    /// Notifies that a step has been removed.
    /// </summary>
    /// <param name="name">The name of the step.</param>
    internal void NotifyStepRemoved(string name)
    {
        if (_stepItems.Contains(name))
            _stepItems.Remove(name);
    }

    /// <summary>
    /// Selects the specified step.
    /// </summary>
    /// <param name="stepName">The name of the step to select.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    public Task SelectStep(string stepName)
    {
        SelectedStep = stepName;
        return Task.CompletedTask;
    }

    /// <summary>
    /// Moves to the next step.
    /// </summary>
    /// <returns>A task that represents the asynchronous operation.</returns>
    public Task NextStep()
    {
        var selectedStepIndex = _stepItems.IndexOf(SelectedStep);

        if (selectedStepIndex == -1 || selectedStepIndex == _stepItems.Count - 1)
        {
            return Task.CompletedTask;
        }

        var nextStep = _stepItems[selectedStepIndex + 1];
        SelectedStep = nextStep;
        return Task.CompletedTask;
    }

    /// <summary>
    /// Moves to the previous step.
    /// </summary>
    /// <returns>A task that represents the asynchronous operation.</returns>
    public Task PreviousStep()
    {
        var selectedStepIndex = _stepItems.IndexOf(SelectedStep);

        if (selectedStepIndex <= 0)
        {
            return Task.CompletedTask;
        }

        SelectedStep = _stepItems[selectedStepIndex - 1];
        return Task.CompletedTask;
    }

    /// <summary>
    /// Gets the index of the specified step.
    /// </summary>
    /// <param name="name">The name of the step.</param>
    /// <returns>The 1-based index of the step.</returns>
    public int IndexOfStep(string name)
    {
        return _stepItems.IndexOf(name) + 1;
    }

    /// <summary>
    /// Notifies that a step panel has been initialized.
    /// </summary>
    /// <param name="name">The name of the step panel.</param>
    internal void NotifyStepPanelInitialized(string name)
    {
        if (!_stepPanels.Contains(name))
            _stepPanels.Add(name);
    }

    /// <summary>
    /// Notifies that a step panel has been removed.
    /// </summary>
    /// <param name="name">The name of the step panel.</param>
    internal void NotifyStepPanelRemoved(string name)
    {
        if (_stepPanels.Contains(name))
            _stepPanels.Remove(name);
    }

    protected override Dictionary<string, object> BuildAttributes()
    {
        var attributes = base.BuildAttributes();

        BuildClassAttribute(attributes, (ref PooledStringBuilder cls) =>
        {
            AppendClass(ref cls, "steps");

            if (RenderMode == StepsRenderMode.LazyLoad)
                AppendClass(ref cls, "steps-lazy-load");
            else if (RenderMode == StepsRenderMode.LazyReload)
                AppendClass(ref cls, "steps-lazy-reload");
        });

        return attributes;
    }

    private void HandleLocationChanged(object? sender, LocationChangedEventArgs args)
    {
        var fragment = GetFragment(args.Location);
        if (!fragment.HasContent())
            return;

        if (_stepItems.Contains(fragment) && fragment != _state.SelectedStep)
        {
            _state = _state with { SelectedStep = fragment };
            AriaDescribedBy = _state.SelectedStep;
            SelectedStepChanged.InvokeAsync(_state.SelectedStep);
            StateHasChanged();
        }
    }

    private string GetFragment(string? uri = null)
    {
        var current = uri ?? Navigation.Uri;
        try
        {
            var u = new Uri(current);
            var frag = u.Fragment;
            return string.IsNullOrEmpty(frag) ? string.Empty : frag.TrimStart('#');
        }
        catch
        {
            return string.Empty;
        }
    }

    public override void Dispose()
    {
        if (_navigationSubscribed)
        {
            Navigation.LocationChanged -= HandleLocationChanged;
            _navigationSubscribed = false;
        }

        base.Dispose();
    }

}