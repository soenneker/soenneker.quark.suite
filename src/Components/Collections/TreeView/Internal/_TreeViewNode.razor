@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Soenneker.Blazor.Extensions.EventCallback
@typeparam TNode
@namespace Soenneker.Quark
@inherits Soenneker.Quark.Element

<div @attributes="BuildAttributes()">
    @if (NodeStates is not null)
    {
        if (Virtualize)
        {
            <Virtualize TItem="TreeViewNodeState<TNode>" Context="node" Items="@NodeStates">
                @NodeFragment(node)
            </Virtualize>
        }
        else
        {
            @foreach (TreeViewNodeState<TNode> nodeState in NodeStates)
            {
                @NodeFragment(nodeState)
            }
        }
    }
</div>

@code {
    [Parameter] public ICollection<TreeViewNodeState<TNode>>? NodeStates { get; set; }
    [Parameter] public RenderFragment<TNode>? NodeContent { get; set; }

    [Parameter] public IList<TNode> ExpandedNodes { get; set; } = new List<TNode>();
    [Parameter] public EventCallback<IList<TNode>> ExpandedNodesChanged { get; set; }

    [Parameter] public Func<TNode, IEnumerable<TNode>>? GetChildNodes { get; set; }
    [Parameter] public Func<TNode, Task<IEnumerable<TNode>>>? GetChildNodesAsync { get; set; }
    [Parameter] public Func<TNode, bool>? HasChildNodes { get; set; }
    [Parameter] public Func<TNode, Task<bool>>? HasChildNodesAsync { get; set; }
    [Parameter] public Func<TNode, bool>? IsDisabled { get; set; }

    [Parameter] public TreeViewSelectionMode SelectionMode { get; set; }
    [Parameter] public bool ToggleOnNodeClick { get; set; }
    [Parameter] public bool AutoExpandAll { get; set; }
    [Parameter] public bool Virtualize { get; set; }

    [Parameter] public string ExpandIconName { get; set; } = "chevron-right";
    [Parameter] public IconStyle? ExpandIconStyle { get; set; }
    [Parameter] public IconSize? ExpandIconSize { get; set; }

    [Parameter] public string CollapseIconName { get; set; } = "chevron-down";
    [Parameter] public IconStyle? CollapseIconStyle { get; set; }
    [Parameter] public IconSize? CollapseIconSize { get; set; }

    [Parameter] public Action<TNode, NodeStyling>? SelectedNodeStyling { get; set; }
    [Parameter] public Action<TNode, NodeStyling>? DisabledNodeStyling { get; set; }
    [Parameter] public Action<TNode, NodeStyling>? NodeStyling { get; set; }

    [Parameter] public EventCallback<TreeViewNodeMouseEventArgs<TNode>> ContextMenu { get; set; }
    [Parameter] public bool ContextMenuPreventDefault { get; set; }

    [CascadingParameter(Name = nameof(ParentTreeView))] public TreeView<TNode>? ParentTreeView { get; set; }

    protected override void BuildAttributesCore(Dictionary<string, object> attributes)
    {
        BuildClassAttribute(attributes, (ref cls) => AppendClass(ref cls, "q-tree-view-node"));
    }

    protected override async Task OnInitializedAsync()
    {
        if (AutoExpandAll && NodeStates is not null)
        {
            // Expand without repainting per node; repaint once at end.
            var any = false;

            foreach (TreeViewNodeState<TNode> node in NodeStates)
            {
                if (node.HasChildren && !node.Expanded)
                {
                    await ToggleNode(node, refresh: false);
                    any = true;
                }
            }

            if (any)
            {
                await RefreshOffThread();
            }
        }

        await base.OnInitializedAsync();
    }

    protected override async Task OnParametersSetAsync()
    {
        // If parameters bring in expanded nodes that have not loaded children yet, load them.
        // Refresh once at the end if we actually loaded anything.
        var changed = false;

        if (NodeStates is not null)
        {
            foreach (TreeViewNodeState<TNode> node in NodeStates)
            {
                if (node.Expanded && node.HasChildren && node.Children.Count == 0)
                {
                    await LoadChildNodes(node);
                    changed = true;
                }
            }
        }

        await base.OnParametersSetAsync();

        if (changed)
        {
            await RefreshOffThread();
        }
    }

    private RenderFragment NodeFragment(TreeViewNodeState<TNode> nodeState) => __builder =>
    {
        <div class="q-tree-view-node-row"
             @key="nodeState.Key"
             @oncontextmenu="e => OnContextMenuHandler(nodeState, e)"
             @oncontextmenu:stopPropagation
             @oncontextmenu:preventDefault="@ContextMenuPreventDefault">

            @if (nodeState.HasChildren)
            {
                <span class="q-tree-view-node-toggle" @onclick="() => ToggleNode(nodeState, true)">
                    @if (nodeState.Expanded)
                    {
                        <Icon Name="@CollapseIconName" IconStyle="@CollapseIconStyle" IconSize="@CollapseIconSize" />
                    }
                    else
                    {
                        <Icon Name="@ExpandIconName" IconStyle="@ExpandIconStyle" IconSize="@ExpandIconSize" />
                    }
                </span>
            }

            <_TreeViewNodeContent TNode="TNode"
                                  NodeState="@nodeState"
                                  NodeStyling="@NodeStyling"
                                  SelectionMode="@SelectionMode"
                                  SelectedNodeStyling="@SelectedNodeStyling"
                                  DisabledNodeStyling="@DisabledNodeStyling"
                                  OnTitleClicked="@(() => OnTitleClicked(nodeState))">
                @NodeContent!(nodeState.Node)
            </_TreeViewNodeContent>
        </div>

        @if (nodeState.Expanded && nodeState.HasChildren)
        {
            <_TreeViewNode TNode="TNode"
                           NodeStates="@nodeState.Children"
                           NodeContent="@NodeContent"
                           GetChildNodes="@GetChildNodes"
                           GetChildNodesAsync="@GetChildNodesAsync"
                           ExpandedNodes="@ExpandedNodes"
                           ExpandedNodesChanged="@ExpandedNodesChanged"
                           AutoExpandAll="@AutoExpandAll"
                           HasChildNodes="@HasChildNodes"
                           IsDisabled="@IsDisabled"
                           HasChildNodesAsync="@HasChildNodesAsync"
                           NodeStyling="@NodeStyling"
                           SelectedNodeStyling="@SelectedNodeStyling"
                           DisabledNodeStyling="@DisabledNodeStyling"
                           ExpandIconName="@ExpandIconName"
                           ExpandIconStyle="@ExpandIconStyle"
                           ExpandIconSize="@ExpandIconSize"
                           CollapseIconName="@CollapseIconName"
                           CollapseIconStyle="@CollapseIconStyle"
                           CollapseIconSize="@CollapseIconSize"
                           SelectionMode="@SelectionMode"
                           ToggleOnNodeClick="@ToggleOnNodeClick"
                           ContextMenu="@ContextMenu"
                           ContextMenuPreventDefault="@ContextMenuPreventDefault"
                           Virtualize="@Virtualize" />
        }
    };

    private async Task ToggleNode(TreeViewNodeState<TNode> nodeState, bool refresh)
    {
        nodeState.Expanded = !nodeState.Expanded;

        if (nodeState.Expanded)
        {
            if (!ExpandedNodes.Contains(nodeState.Node))
            {
                ExpandedNodes.Add(nodeState.Node);
                await ExpandedNodesChanged.InvokeIfHasDelegate(ExpandedNodes);
            }

            if (nodeState.HasChildren)
                await LoadChildNodes(nodeState);
        }
        else
        {
            if (ExpandedNodes.Remove(nodeState.Node))
                await ExpandedNodesChanged.InvokeIfHasDelegate(ExpandedNodes);
        }

        if (refresh)
        {
            await RefreshOffThread();
        }
    }

    private async Task LoadChildNodes(TreeViewNodeState<TNode> nodeState)
    {
        IEnumerable<TNode>? children = null;

        if (GetChildNodesAsync is not null)
            children = await GetChildNodesAsync(nodeState.Node);
        else if (GetChildNodes is not null)
            children = GetChildNodes(nodeState.Node);

        nodeState.Children.Clear();

        if (children is null)
            return;

        foreach (TNode child in children)
        {
            bool hasChildren = await DetermineHasChildren(child);
            bool expanded = ExpandedNodes.Contains(child);
            bool disabled = DetermineIsDisabled(child);

            nodeState.Children.Add(new TreeViewNodeState<TNode>(child, hasChildren, expanded, disabled));
        }
    }

    private bool DetermineIsDisabled(TNode node) => IsDisabled?.Invoke(node) ?? false;

    private async ValueTask<bool> DetermineHasChildren(TNode node)
    {
        if (HasChildNodesAsync is not null)
            return await HasChildNodesAsync(node);

        if (HasChildNodes is not null)
            return HasChildNodes(node);

        return false;
    }

    private Task OnContextMenuHandler(TreeViewNodeState<TNode> nodeState, MouseEventArgs e)
    {
        if (!ContextMenu.HasDelegate)
            return Task.CompletedTask;

        return ContextMenu.InvokeAsync(new TreeViewNodeMouseEventArgs<TNode>(nodeState.Node, e));
    }

    private Task OnTitleClicked(TreeViewNodeState<TNode> nodeState)
    {
        if (ToggleOnNodeClick && nodeState.HasChildren)
            return ToggleNode(nodeState, refresh: true);

        return Task.CompletedTask;
    }

    protected override void ComputeRenderKeyCore(ref HashCode hc)
    {
        // Structural inputs
        hc.Add(NodeContent);
        hc.Add(SelectionMode);
        hc.Add(ToggleOnNodeClick);
        hc.Add(AutoExpandAll);
        hc.Add(Virtualize);

        hc.Add(ExpandIconName);
        hc.Add(ExpandIconStyle);
        hc.Add(ExpandIconSize);

        hc.Add(CollapseIconName);
        hc.Add(CollapseIconStyle);
        hc.Add(CollapseIconSize);

        hc.Add(SelectedNodeStyling);
        hc.Add(DisabledNodeStyling);
        hc.Add(NodeStyling);

        hc.Add(GetChildNodes);
        hc.Add(GetChildNodesAsync);
        hc.Add(HasChildNodes);
        hc.Add(HasChildNodesAsync);
        hc.Add(IsDisabled);

        hc.Add(ContextMenuPreventDefault);
        hc.Add(ContextMenu);

        // Keep this cheap (this component is recursive).
        if (NodeStates is not null)
        {
            hc.Add(NodeStates.Count);

            // sample a few keys for change detection without O(n) walk every time
            var sample = 0;
            foreach (TreeViewNodeState<TNode> ns in NodeStates)
            {
                hc.Add(ns.Key);
                if (++sample == 3)
                    break;
            }
        }

        if (ExpandedNodes is not null)
            hc.Add(ExpandedNodes.Count);
    }
}
