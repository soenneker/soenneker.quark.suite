@typeparam TNode
@namespace Soenneker.Quark

@using Soenneker.Blazor.Extensions.EventCallback
@inherits Soenneker.Quark.Element

<CascadingValue Name="ParentTreeView" Value="@this" IsFixed="true">
    <CascadingValue Name="ParentTreeViewState" Value="@_state" IsFixed="true">
        <div @attributes="BuildAttributes()">
            <_TreeViewNode TNode="TNode"
                           NodeStates="@_rootNodeStates"
                           NodeContent="@NodeContent"
                           GetChildNodes="@GetChildNodes"
                           GetChildNodesAsync="@GetChildNodesAsync"
                           ExpandedNodes="@ExpandedNodes"
                           ExpandedNodesChanged="@ExpandedNodesChanged"
                           AutoExpandAll="@AutoExpandAll"
                           HasChildNodes="@HasChildNodes"
                           IsDisabled="@IsDisabled"
                           HasChildNodesAsync="@HasChildNodesAsync"
                           NodeStyling="@NodeStyling"
                           SelectedNodeStyling="@SelectedNodeStyling"
                           DisabledNodeStyling="@DisabledNodeStyling"
                           SelectionMode="@SelectionMode"
                           ToggleOnNodeClick="@ToggleOnNodeClick"
                           ExpandIconName="@ExpandIconName"
                           ExpandIconStyle="@ExpandIconStyle"
                           ExpandIconSize="@ExpandIconSize"
                           CollapseIconName="@CollapseIconName"
                           CollapseIconStyle="@CollapseIconStyle"
                           CollapseIconSize="@CollapseIconSize"
                           ContextMenu="@NodeContextMenu"
                           ContextMenuPreventDefault="@NodeContextMenuPreventDefault"
                           Virtualize="@Virtualize">
            </_TreeViewNode>
        </div>
    </CascadingValue>
</CascadingValue>

@code {
    // shadcn - new-york-v4
    private readonly TreeViewState<TNode> _state = new() { SelectedNodes = new List<TNode>() };
    private List<TreeViewNodeState<TNode>> _rootNodeStates = [];

    private int _nodesKey;
    private int _expandedKey;
    private int _selectedKey;

    [Inject] internal ITreeViewInterop? Interop { get; set; }

    [Parameter] public IEnumerable<TNode>? Nodes { get; set; }
    [Parameter] public RenderFragment<TNode>? NodeContent { get; set; }

    [Parameter] public TNode? SelectedNode { get; set; }
    [Parameter] public EventCallback<TNode?> SelectedNodeChanged { get; set; }

    [Parameter] public IList<TNode>? SelectedNodes { get; set; }
    [Parameter] public EventCallback<IList<TNode>?> SelectedNodesChanged { get; set; }

    [Parameter] public TreeViewSelectionMode SelectionMode { get; set; }

    [Parameter] public bool AutoExpandAll { get; set; }
    [Parameter] public bool Virtualize { get; set; }
    [Parameter] public bool ToggleOnNodeClick { get; set; } = true;

    [Parameter] public IList<TNode> ExpandedNodes { get; set; } = new List<TNode>();
    [Parameter] public EventCallback<IList<TNode>> ExpandedNodesChanged { get; set; }

    [Parameter] public Func<TNode, IEnumerable<TNode>>? GetChildNodes { get; set; }
    [Parameter] public Func<TNode, Task<IEnumerable<TNode>>>? GetChildNodesAsync { get; set; }
    [Parameter] public Func<TNode, bool>? HasChildNodes { get; set; }
    [Parameter] public Func<TNode, Task<bool>>? HasChildNodesAsync { get; set; }
    [Parameter] public Func<TNode, bool>? IsDisabled { get; set; }

    [Parameter] public Action<TNode, NodeStyling>? SelectedNodeStyling { get; set; }
    [Parameter] public Action<TNode, NodeStyling>? DisabledNodeStyling { get; set; }
    [Parameter] public Action<TNode, NodeStyling>? NodeStyling { get; set; }

    [Parameter] public string ExpandIconName { get; set; } = "chevron-right";
    [Parameter] public IconStyle? ExpandIconStyle { get; set; }
    [Parameter] public IconSize? ExpandIconSize { get; set; }

    [Parameter] public string CollapseIconName { get; set; } = "chevron-down";
    [Parameter] public IconStyle? CollapseIconStyle { get; set; }
    [Parameter] public IconSize? CollapseIconSize { get; set; }

    [Parameter] public EventCallback<TreeViewNodeMouseEventArgs<TNode>> NodeContextMenu { get; set; }
    [Parameter] public bool NodeContextMenuPreventDefault { get; set; }

    protected override void BuildAttributesCore(Dictionary<string, object> attributes)
    {
        BuildClassAttribute(attributes, (ref cls) => AppendClass(ref cls, "q-tree-view"));
    }

    protected override async Task OnParametersSetAsync()
    {
        // Sync cascading state
        _state.SelectionMode = SelectionMode;
        _state.SelectedNode = SelectedNode;
        _state.SelectedNodes = SelectedNodes ?? _state.SelectedNodes ?? new List<TNode>();

        // Only rebuild root node states When the effective inputs that affect them change
        var nodesKey = HashSeq(Nodes);
        var expandedKey = HashSeq(ExpandedNodes);
        var selectedKey = HashSeq(SelectedNodes);

        var rebuild = nodesKey != _nodesKey || expandedKey != _expandedKey;

        _nodesKey = nodesKey;
        _expandedKey = expandedKey;
        _selectedKey = selectedKey;

        if (rebuild)
        {
            await EnsureNodesLoaded();
            InvalidateRender();
        }

        await base.OnParametersSetAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            if (Interop is not null)
                await Interop.Initialize();
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    private async Task EnsureNodesLoaded()
    {
        var nodes = Nodes;

        var capacity = 0;
        if (nodes is ICollection<TNode> c)
            capacity = c.Count;

        var list = new List<TreeViewNodeState<TNode>>(capacity > 0 ? capacity : 16);

        if (nodes is not null)
        {
            foreach (var node in nodes)
            {
                var hasChildren = await DetermineHasChildren(node);
                var expanded = ExpandedNodes.Contains(node);
                var disabled = DetermineIsDisabled(node);
                list.Add(new TreeViewNodeState<TNode>(node, hasChildren, expanded, disabled));
            }
        }

        _rootNodeStates = list;
    }

    private bool DetermineIsDisabled(TNode node) => IsDisabled?.Invoke(node) ?? false;

    private async ValueTask<bool> DetermineHasChildren(TNode node)
    {
        if (HasChildNodesAsync is not null)
            return await HasChildNodesAsync(node);

        if (HasChildNodes is not null)
            return HasChildNodes(node);

        return false;
    }

    public async ValueTask SelectNode(TNode node)
    {
        if (_state.SelectionMode == TreeViewSelectionMode.Multiple)
            return;

        if (EqualityComparer<TNode>.Default.Equals(_state.SelectedNode, node))
            return;

        _state.SelectedNode = node;

        InvalidateRender();

        await SelectedNodeChanged.InvokeAsync(_state.SelectedNode);

        await RefreshOffThread();
    }

    public async Task ToggleCheckNode(TNode node)
    {
        if (_state.SelectionMode == TreeViewSelectionMode.Single)
            return;

        var list = _state.SelectedNodes ??= new List<TNode>();

        if (list.Contains(node))
            list.Remove(node);
        else
            list.Add(node);

        InvalidateRender();

        await SelectedNodesChanged.InvokeIfHasDelegate(list);

        await RefreshOffThread();
    }

    private static int HashSeq(IEnumerable<TNode>? seq)
    {
        if (seq is null)
            return 0;

        var hc = new HashCode();

        if (seq is ICollection<TNode> c)
            hc.Add(c.Count);

        foreach (var n in seq)
            hc.Add(n);

        return hc.ToHashCode();
    }

    protected override void ComputeRenderKeyCore(ref HashCode hc)
    {
        base.ComputeRenderKeyCore(ref hc);

        hc.Add(NodeContent);

        hc.Add(SelectedNode);
        hc.Add(SelectionMode);

        hc.Add(AutoExpandAll);
        hc.Add(Virtualize);
        hc.Add(ToggleOnNodeClick);

        hc.Add(ExpandIconName);
        hc.Add(ExpandIconStyle);
        hc.Add(ExpandIconSize);

        hc.Add(CollapseIconName);
        hc.Add(CollapseIconStyle);
        hc.Add(CollapseIconSize);

        hc.Add(NodeContextMenuPreventDefault);

        hc.Add(GetChildNodes);
        hc.Add(GetChildNodesAsync);
        hc.Add(HasChildNodes);
        hc.Add(HasChildNodesAsync);
        hc.Add(IsDisabled);

        hc.Add(NodeStyling);
        hc.Add(SelectedNodeStyling);
        hc.Add(DisabledNodeStyling);

        hc.Add(NodeContextMenu);

        // Cheap, stable-ish keys instead of enumerating potentially huge sequences every render
        hc.Add(_nodesKey);
        hc.Add(_expandedKey);
        hc.Add(_selectedKey);
    }
}
