@namespace Soenneker.Quark
@inherits Soenneker.Quark.Element
@using Soenneker.Blazor.Extensions.EventCallback
@implements IAccordion

<CascadingValue Name="ParentAccordion" Value="this">
    <div @attributes="BuildAttributes()">
        @ChildContent
    </div>
</CascadingValue>

@code {
    /// <summary>
    /// Gets or sets whether multiple items can be expanded at the same time.
    /// </summary>
    [Parameter]
    public bool AllowMultiple { get; set; }

    /// <summary>
    /// Gets or sets the array of expanded item names.
    /// </summary>
    [Parameter]
    public string[] ExpandedItems { get; set; } = [];

    /// <summary>
    /// Gets or sets the callback invoked when the expanded items change.
    /// </summary>
    [Parameter]
    public EventCallback<string[]> OnExpandedItemsChanged { get; set; }

    /// <summary>
    /// Gets or sets whether the accordion should be flush (no borders/rounded corners).
    /// </summary>
    [Parameter]
    public bool Flush { get; set; }

    private readonly List<AccordionItem> _items = [];

    protected override void OnInitialized()
    {
        if (Id.IsNullOrEmpty())
            Id = $"accordion_{Guid.NewGuid():N}";
    }

    /// <summary>
    /// Registers an accordion item.
    /// </summary>
    /// <param name="item">The accordion item to register.</param>
    public void RegisterItem(AccordionItem item)
    {
        if (!_items.Contains(item))
        {
            _items.Add(item);
        }
    }

    /// <summary>
    /// Unregisters an accordion item.
    /// </summary>
    /// <param name="item">The accordion item to unregister.</param>
    public void UnregisterItem(AccordionItem item)
    {
        _items.Remove(item);
    }

    /// <summary>
    /// Toggles the expanded state of the specified item.
    /// </summary>
    /// <param name="itemName">The name of the item to toggle.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    public async Task ToggleItem(string itemName)
    {
        if (string.IsNullOrEmpty(itemName))
            return;

        var current = ExpandedItems;

        string[] next;

        if (!AllowMultiple)
        {
            // single-open mode
            if (current.Length == 1 && string.Equals(current[0], itemName, StringComparison.Ordinal))
                next = [];
            else
                next = [itemName];
        }
        else
        {
            // multi-open mode
            var idx = Array.IndexOf(current, itemName);

            if (idx >= 0)
            {
                if (current.Length == 1)
                {
                    next = [];
                }
                else
                {
                    next = new string[current.Length - 1];
                    if (idx != 0)
                        Array.Copy(current, 0, next, 0, idx);
                    if (idx != current.Length - 1)
                        Array.Copy(current, idx + 1, next, idx, current.Length - idx - 1);
                }
            }
            else
            {
                next = new string[current.Length + 1];
                if (current.Length != 0)
                    Array.Copy(current, next, current.Length);
                next[^1] = itemName;
            }
        }

        ExpandedItems = next;

        await OnExpandedItemsChanged.InvokeIfHasDelegate(next);

        InvalidateRender();
        Refresh();
    }

    /// <summary>
    /// Determines whether the specified item is expanded.
    /// </summary>
    /// <param name="itemName">The name of the item.</param>
    /// <returns>True if the item is expanded; otherwise, false.</returns>
    public bool IsItemExpanded(string itemName)
    {
        var arr = ExpandedItems;
        return arr is not null && Array.IndexOf(arr, itemName) >= 0;
    }

    protected override void BuildAttributesCore(Dictionary<string, object> attributes)
    {
        base.BuildAttributesCore(attributes);

        BuildClassAttribute(attributes, (ref cls) =>
        {
            AppendClass(ref cls, "q-accordion");
            AppendClass(ref cls, "accordion");

            if (Flush)
            {
                AppendClass(ref cls, "accordion-flush");
            }
        });

        attributes["id"] = Id!;
        attributes["role"] = "tablist";
    }

    protected override void ComputeRenderKeyCore(ref HashCode hc)
    {
        hc.Add(AllowMultiple);
        hc.Add(Flush);
        if (ExpandedItems != null)
        {
            hc.Add(ExpandedItems.Length);
            foreach (var item in ExpandedItems)
            {
                hc.Add(item);
            }
        }
    }
}