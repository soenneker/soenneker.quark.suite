@using System.Globalization
@using System.Linq.Expressions
@using Soenneker.Blazor.Extensions.EventCallback
@using Soenneker.Quark.Components.Validations
@using Soenneker.Quark.Enums

@inherits Soenneker.Quark.Element
@implements Soenneker.Quark.IValidationInput

<input type="number" @attributes="BuildAttributes()" />

@code {
    public override string? ThemeKey { get; set; } = "NumericEdit";

    [Parameter]
    public decimal? Value { get; set; }

    [Parameter]
    public string? Placeholder { get; set; }

    [Parameter]
    public bool Disabled { get; set; }

    [Parameter]
    public bool ReadOnly { get; set; }

    [Parameter]
    public bool Required { get; set; }

    [Parameter]
    public decimal? Min { get; set; }

    [Parameter]
    public decimal? Max { get; set; }

    [Parameter]
    public decimal? Step { get; set; }

	[Parameter]
	public CssValue<ColorBuilder>? Color { get; set; }

    [Parameter]
    public CssValue<SizeBuilder>? Size { get; set; } = Quark.Size.Default;

    [Parameter]
    public EventCallback<decimal?> ValueChanged { get; set; }

    [Parameter]
    public Expression<Func<decimal?>>? ValueExpression { get; set; }

    [Parameter]
    public EventCallback<ChangeEventArgs> OnChange { get; set; }

    [Parameter]
    public EventCallback<ChangeEventArgs> OnInput { get; set; }

    [CascadingParameter]
    public Validation? ParentValidation { get; set; }

    public object? ValidationValue => Value;

    private static decimal? ParseDecimal(ChangeEventArgs e)
    {
        if (e?.Value == null)
            return null;

        var text = e.Value.ToString();

        if (decimal.TryParse(text, NumberStyles.Any, CultureInfo.InvariantCulture, out decimal result))
            return result;

        return null;
    }

    private async Task HandleInput(ChangeEventArgs e)
    {
        Value = ParseDecimal(e);
        await ValueChanged.InvokeIfHasDelegate(Value);

        await OnInput.InvokeIfHasDelegate(e);

        if (ParentValidation is not null)
            await ParentValidation.NotifyInputChanged(Value);
    }

    private async Task HandleChange(ChangeEventArgs e)
    {
        Value = ParseDecimal(e);
        await ValueChanged.InvokeIfHasDelegate(Value);

        await OnChange.InvokeIfHasDelegate(e);

        if (ParentValidation is not null)
            await ParentValidation.NotifyInputChanged(Value);
    }

    private string? GetSizeClass()
    {
        if (Size == Quark.Size.Small)
            return "form-control-sm";

        if (Size == Quark.Size.Large)
            return "form-control-lg";

        return null;
    }

    private string? GetColorClass()
    {
        if (Color is not null && !Color.Value.IsEmpty)
        {
            string v = Color.Value.ToString().Trim();

            if (Color.Value.IsCssClass)
            {
                if (v.StartsWith("form-control-", StringComparison.Ordinal))
                    return v;

                return $"form-control-{v}";
            }
        }

        return null;
    }

    private string? GetValidationClass()
    {
        if (ParentValidation?.Status == ValidationStatus.Error)
            return "is-invalid";

        if (ParentValidation?.Status == ValidationStatus.Success)
            return "is-valid";

        return null;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && ParentValidation is not null)
        {
            await ParentValidation.InitializeInput(this);

            if (ValueExpression is not null)
            {
                await ParentValidation.InitializeInputExpression(ValueExpression);
            }
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    protected override Dictionary<string, object> BuildAttributes()
    {
        Dictionary<string, object> attributes = base.BuildAttributes();

        var baseClasses = "form-control";
        string? colorClass = GetColorClass();
        string? sizeClass = GetSizeClass();
        string? validationClass = GetValidationClass();

        if (colorClass != null)
            baseClasses = $"{baseClasses} {colorClass}";
        if (sizeClass != null)
            baseClasses = $"{baseClasses} {sizeClass}";
        if (validationClass != null)
            baseClasses = $"{baseClasses} {validationClass}";

        AppendToClassAttr(attributes, baseClasses);

        // Handle custom CSS colors
        if (Color is not null && !Color.Value.IsEmpty && !Color.Value.IsCssClass)
        {
            string v = Color.Value.ToString().Trim();
            attributes["style"] = $"background-color:{v};border-color:{v};";
        }

        if (Value.HasValue)
            attributes["value"] = Value.Value.ToString(CultureInfo.InvariantCulture);

        if (!string.IsNullOrEmpty(Placeholder))
            attributes["placeholder"] = Placeholder;

        if (Disabled)
            attributes["disabled"] = true;

        if (ReadOnly)
            attributes["readonly"] = true;

        if (Required)
            attributes["required"] = true;

        if (Min.HasValue)
            attributes["min"] = Min.Value.ToString(CultureInfo.InvariantCulture);

        if (Max.HasValue)
            attributes["max"] = Max.Value.ToString(CultureInfo.InvariantCulture);

        if (Step.HasValue)
            attributes["step"] = Step.Value.ToString(CultureInfo.InvariantCulture);

        // Wire input/change events to keep Value in sync without using @bind on this element
        attributes["oninput"] = EventCallback.Factory.Create<ChangeEventArgs>(this, HandleInput);
        attributes["onchange"] = EventCallback.Factory.Create<ChangeEventArgs>(this, HandleChange);

        return attributes;
    }

}
