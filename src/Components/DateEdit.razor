@using System.Linq.Expressions
@using Soenneker.Blazor.Extensions.EventCallback

@namespace Soenneker.Quark
@inherits Soenneker.Quark.Input
@implements IDateEdit

@code {
	public override string? ThemeKey { get; set; } = "DateEdit";

	[Parameter]
	public DateTime? Date { get; set; }

	[Parameter]
	public Expression<Func<DateTime>>? DateExpression { get; set; }

	[Parameter]
	public DateOnly? DateOnly { get; set; }

	[Parameter]
	public Expression<Func<DateOnly>>? DateOnlyExpression { get; set; }

	[Parameter]
	public DateTime Min { get; set; }

	[Parameter]
	public DateTime Max { get; set; }

	[Parameter]
	public DateOnly MinDateOnly { get; set; }

	[Parameter]
	public DateOnly MaxDateOnly { get; set; }

	[Parameter]
	public int Step { get; set; } = 1;

	[Parameter]
	public DateInputMode InputMode { get; set; } = DateInputMode.Date;

	[Parameter]
	public EventCallback<DateTime?> DateChanged { get; set; }

	[Parameter]
	public EventCallback<DateOnly?> DateOnlyChanged { get; set; }

	public override object? ValidationValue => Date ?? (object?)DateOnly;

	protected override string GetInputType()
	{
		return GetInputModeString();
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender && ParentValidation is not null)
		{
			if (DateExpression is not null)
			{
				await ParentValidation.InitializeInputExpression(DateExpression);
			}
			else if (DateOnlyExpression is not null)
			{
				await ParentValidation.InitializeInputExpression(DateOnlyExpression);
			}
		}

		await base.OnAfterRenderAsync(firstRender);
	}

	protected override async Task HandleInput(ChangeEventArgs e)
	{
		var value = e.Value?.ToString();
		
		if (DateExpression is not null || Date.HasValue || DateChanged.HasDelegate)
		{
			if (DateTime.TryParse(value, out var dateValue))
			{
				Date = dateValue;
			}
			await DateChanged.InvokeIfHasDelegate(Date);
		}
		else if (DateOnlyExpression is not null || DateOnly.HasValue || DateOnlyChanged.HasDelegate)
		{
			if (System.DateOnly.TryParse(value, out var dateOnlyValue))
			{
				DateOnly = dateOnlyValue;
			}
			await DateOnlyChanged.InvokeIfHasDelegate(DateOnly);
		}

		await base.HandleInput(e);
	}

	protected override async Task HandleChange(ChangeEventArgs e)
	{
		var value = e?.Value?.ToString();
		
		if (DateExpression is not null || Date.HasValue || DateChanged.HasDelegate)
		{
			if (DateTime.TryParse(value, out var dateValue))
			{
				Date = dateValue;
			}
			await DateChanged.InvokeIfHasDelegate(Date);
		}
		else if (DateOnlyExpression is not null || DateOnly.HasValue || DateOnlyChanged.HasDelegate)
		{
			if (System.DateOnly.TryParse(value, out var dateOnlyValue))
			{
				DateOnly = dateOnlyValue;
			}
			await DateOnlyChanged.InvokeIfHasDelegate(DateOnly);
		}

		await base.HandleChange(e);
	}

	private string GetInputModeString()
	{
		return InputMode.Value;
	}

	protected override Dictionary<string, object> BuildAttributes()
	{
		var attributes = base.BuildAttributes();

		// Add DateEdit-specific attributes
		attributes["type"] = GetInputModeString();

		if (Date.HasValue)
		{
			var dateString = InputMode.Value switch
			{
				"date" => Date.Value.ToString("yyyy-MM-dd"),
				"datetime-local" => Date.Value.ToString("yyyy-MM-ddTHH:mm"),
				"month" => Date.Value.ToString("yyyy-MM"),
				_ => Date.Value.ToString("yyyy-MM-dd")
			};
			attributes["value"] = dateString;
		}
		else if (DateOnly.HasValue)
		{
			var dateString = InputMode.Value switch
			{
				"date" => DateOnly.Value.ToString("yyyy-MM-dd"),
				"datetime-local" => DateOnly.Value.ToString("yyyy-MM-ddTHH:mm"),
				"month" => DateOnly.Value.ToString("yyyy-MM"),
				_ => DateOnly.Value.ToString("yyyy-MM-dd")
			};
			attributes["value"] = dateString;
		}

		if (Min != default)
		{
			var minString = InputMode.Value switch
			{
				"date" => Min.ToString("yyyy-MM-dd"),
				"datetime-local" => Min.ToString("yyyy-MM-ddTHH:mm"),
				"month" => Min.ToString("yyyy-MM"),
				_ => Min.ToString("yyyy-MM-dd")
			};
			attributes["min"] = minString;
		}
		else if (MinDateOnly != default)
		{
			var minString = InputMode.Value switch
			{
				"date" => MinDateOnly.ToString("yyyy-MM-dd"),
				"datetime-local" => MinDateOnly.ToString("yyyy-MM-ddTHH:mm"),
				"month" => MinDateOnly.ToString("yyyy-MM"),
				_ => MinDateOnly.ToString("yyyy-MM-dd")
			};
			attributes["min"] = minString;
		}

		if (Max != default)
		{
			var maxString = InputMode.Value switch
			{
				"date" => Max.ToString("yyyy-MM-dd"),
				"datetime-local" => Max.ToString("yyyy-MM-ddTHH:mm"),
				"month" => Max.ToString("yyyy-MM"),
				_ => Max.ToString("yyyy-MM-dd")
			};
			attributes["max"] = maxString;
		}
		else if (MaxDateOnly != default)
		{
			var maxString = InputMode.Value switch
			{
				"date" => MaxDateOnly.ToString("yyyy-MM-dd"),
				"datetime-local" => MaxDateOnly.ToString("yyyy-MM-ddTHH:mm"),
				"month" => MaxDateOnly.ToString("yyyy-MM"),
				_ => MaxDateOnly.ToString("yyyy-MM-dd")
			};
			attributes["max"] = maxString;
		}

		if (Step > 1)
			attributes["step"] = Step;

		return attributes;
	}

}
