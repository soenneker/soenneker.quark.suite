@namespace Soenneker.Quark
@using Soenneker.Extensions.String
@inherits Soenneker.Quark.Element

<img @attributes="BuildAttributes()" />

@code {
	public override string? ThemeKey { get; set; } = "Image";

    /// <summary>
    /// The absolute or relative URL of the image.
    /// </summary>
    [Parameter]
    public string? Source { get; set; }

    /// <summary>
    /// Alternate text for an image.
    /// </summary>
    [Parameter]
    public string? Alt { get; set; }

    /// <summary>
    /// Forces an image to take up the whole width.
    /// </summary>
    [Parameter]
    public bool Fluid { get; set; }

    /// <summary>
    /// Defers loading the image until it reaches a calculated distance from the viewport.
    /// </summary>
    [Parameter]
    public bool Lazy { get; set; }

    /// <summary>
    /// The loading attribute for the image.
    /// </summary>
    [Parameter]
    public string? Loading { get; set; }

    /// <summary>
    /// The decoding attribute for the image.
    /// </summary>
    [Parameter]
    public string? Decoding { get; set; }

    /// <summary>
    /// The fetchpriority attribute for the image.
    /// </summary>
    [Parameter]
    public string? FetchPriority { get; set; }

    /// <summary>
    /// The sizes attribute for the image.
    /// </summary>
    [Parameter]
    public string? Sizes { get; set; }

    /// <summary>
    /// The srcset attribute for the image.
    /// </summary>
    [Parameter]
    public string? SrcSet { get; set; }

    /// <summary>
    /// The crossorigin attribute for the image.
    /// </summary>
    [Parameter]
    public string? CrossOrigin { get; set; }

    /// <summary>
    /// The referrerpolicy attribute for the image.
    /// </summary>
    [Parameter]
    public string? ReferrerPolicy { get; set; }

    /// <summary>
    /// The usemap attribute for the image.
    /// </summary>
    [Parameter]
    public string? UseMap { get; set; }

    /// <summary>
    /// The ismap attribute for the image.
    /// </summary>
    [Parameter]
    public bool IsMap { get; set; }

    /// <summary>
    /// The longdesc attribute for the image.
    /// </summary>
    [Parameter]
    public string? LongDesc { get; set; }

    /// <summary>
    /// Event callback for when the image loads.
    /// </summary>
    [Parameter]
    public EventCallback<ProgressEventArgs> OnLoad { get; set; }

    /// <summary>
    /// Event callback for when the image fails to load.
    /// </summary>
    [Parameter]
    public EventCallback<ErrorEventArgs> OnError { get; set; }

    /// <summary>
    /// Event callback for when the image starts loading.
    /// </summary>
    [Parameter]
    public EventCallback<ProgressEventArgs> OnLoadStart { get; set; }

    /// <summary>
    /// Event callback for when the image loading is aborted.
    /// </summary>
    [Parameter]
    public EventCallback<ProgressEventArgs> OnAbort { get; set; }

    private string? GetLoadingAttribute()
    {
        if (Lazy)
            return "lazy";
        
        return Loading;
    }

    private string? GetFluidClass()
    {
        if (Fluid)
            return "img-fluid";
        
        return null;
    }

    protected override Dictionary<string, object> BuildAttributes()
    {
        Attributes = base.BuildAttributes();

        // Add default Bootstrap image classes if no class is specified
        if (!Class.HasContent())
        {
            var baseClasses = "img-thumbnail";
            var fluidClass = GetFluidClass();

            if (fluidClass != null)
            {
                baseClasses = $"{baseClasses} {fluidClass}";
            }

            AppendToClassAttr(Attributes, baseClasses);
        }
        else
        {
            // If class is specified, still add fluid class if not already present
            var currentClass = Attributes.GetValueOrDefault("class")
                ?.ToString() ?? "";

            var fluidClass = GetFluidClass();
            if (fluidClass != null && !currentClass.Contains(fluidClass))
            {
                AppendToClassAttr(Attributes, fluidClass);
            }

        }

        // Add image-specific attributes
        if (Source.HasContent())
            Attributes["src"] = Source;

        if (Alt.HasContent())
            Attributes["alt"] = Alt;

        var loadingAttr = GetLoadingAttribute();
        if (loadingAttr.HasContent())
            Attributes["loading"] = loadingAttr;

        if (Decoding.HasContent())
            Attributes["decoding"] = Decoding;

        if (FetchPriority.HasContent())
            Attributes["fetchpriority"] = FetchPriority;

        if (Sizes.HasContent())
            Attributes["sizes"] = Sizes;

        if (SrcSet.HasContent())
            Attributes["srcset"] = SrcSet;

        if (CrossOrigin.HasContent())
            Attributes["crossorigin"] = CrossOrigin;

        if (ReferrerPolicy.HasContent())
            Attributes["referrerpolicy"] = ReferrerPolicy;

        if (UseMap.HasContent())
            Attributes["usemap"] = UseMap;

        if (IsMap)
            Attributes["ismap"] = true;

        if (LongDesc.HasContent())
            Attributes["longdesc"] = LongDesc;

        // Add event handlers
        if (OnLoad.HasDelegate)
            Attributes["onload"] = EventCallback.Factory.Create(this, OnLoad);

        if (OnError.HasDelegate)
            Attributes["onerror"] = EventCallback.Factory.Create(this, OnError);

        if (OnLoadStart.HasDelegate)
            Attributes["onloadstart"] = EventCallback.Factory.Create(this, OnLoadStart);

        if (OnAbort.HasDelegate)
            Attributes["onabort"] = EventCallback.Factory.Create(this, OnAbort);

        return Attributes;
    }
}
