@using Soenneker.Blazor.Extensions.EventCallback
@using Soenneker.Utils.PooledStringBuilders

@namespace Soenneker.Quark
@inherits Soenneker.Quark.CancellableElement
@implements IBar

@inject IBarInterop BarInterop 

<CascadingValue Value="@Mode" IsFixed="true">
    <CascadingValue Value="@HandleBarTogglerClick" IsFixed="true">
        <CascadingValue Value="@_sidebarCollapsed">
            <CascadingValue Value="@_collapseGroupId" IsFixed="true">
                <CascadingValue Value="@_forceCollapseAll">
                    <CascadingValue Value="@_menuId" IsFixed="true">
                        <nav @attributes="BuildAttributes()">
                            @ChildContent
                        </nav>
                    </CascadingValue>
                </CascadingValue>
            </CascadingValue>
        </CascadingValue>
    </CascadingValue>
</CascadingValue>

@code {
    public override string? ThemeKey { get; set; } = "Bar";

    [Parameter]
    public BarMode Mode { get; set; } = BarMode.Horizontal;

    [Parameter]
    public BarPlacement Placement { get; set; } = BarPlacement.Top;

    [Parameter]
    public Alignment Alignment { get; set; } = Alignment.Default;

    [Parameter]
    public bool Expand { get; set; } = true;

    [Parameter]
    public bool Dark { get; set; }

    [Parameter]
    public bool Transparent { get; set; }

    [Parameter]
    public bool Visible { get; set; } = true;

    [Parameter]
    public BarCollapseMode CollapseMode { get; set; } = BarCollapseMode.Hide;

    [Parameter]
    public BarMenuToggleBehavior MenuToggleBehavior { get; set; } = BarMenuToggleBehavior.AllowMultipleMenus;

    [CascadingParameter]
    public bool SidebarVisible { get; set; } = true;

    [CascadingParameter]
    public EventCallback<bool> SidebarVisibleChanged { get; set; }

    private readonly string _collapseGroupId = $"sidebar-accordion-{Guid.NewGuid():N}";
    private readonly string _menuId = $"navbar-menu-{Guid.NewGuid():N}";
    private bool _sidebarCollapsed;
    private bool _forceCollapseAll;

    [Parameter]
    public BreakpointType? Breakpoint { get; set; }

    [Parameter]
    public BreakpointType? NavigationBreakpoint { get; set; }

    protected override bool ShouldRender()
    {
        // For vertical bars with collapsible state, always allow renders
        // because _sidebarCollapsed is internal state not tracked by render key
        if (Mode != BarMode.Horizontal && CollapseMode == BarCollapseMode.Small)
        {
            return true;
        }
        
        return base.ShouldRender();
    }

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        switch (Mode.Value)
        {
            case BarMode.HorizontalValue:
                await BarInterop.InitializeHorizontalBar(CancellationToken);
                break;
            default:
                await BarInterop.InitializeSidebar(CancellationToken);
                break;
        }
    }

    private string GetBaseClass()
    {
        if (Mode == BarMode.Horizontal)
            return "navbar";

        // For vertical mode, don't use navbar classes to avoid collapse behavior
        return "";
    }

    private string? GetPlacementClass()
    {
        if (Placement == BarPlacement.Fixed)
            return $"fixed-{Placement.Value}";

        if (Placement == BarPlacement.Sticky)
            return $"sticky-{Placement.Value}";

        return null;
    }

    private string? GetColorClass()
    {
        if (Dark)
            return "navbar-dark";

        return "navbar-light";
    }


    private string? GetVerticalClass()
    {
        // For vertical mode, don't use navbar classes to avoid collapse behavior
        return null;
    }

    private string? GetExpandClass()
    {
        if (!Expand || Mode != BarMode.Horizontal)
            return null;

        var breakpointToken = BreakpointUtil.GetBreakpointToken(Breakpoint);

        if (breakpointToken.IsNullOrEmpty())
            return "navbar-expand-lg"; // Default

        return $"navbar-expand-{breakpointToken}";
    }

    private string? GetAlignmentClass()
    {
        if (Alignment == Alignment.Default)
            return null;

        return Alignment.Value switch
        {
            Alignment.StartValue => "justify-content-start",
            Alignment.CenterValue => "justify-content-center",
            Alignment.EndValue => "justify-content-end",
            _ => null
        };
    }

    private string? GetCollapseClass()
    {
        if (!Visible)
        {
            return CollapseMode.Value switch
            {
                BarCollapseMode.HideValue => "navbar-hidden",
                BarCollapseMode.SmallValue => "navbar-collapsed",
                _ => "navbar-hidden"
            };
        }

        return null;
    }

    protected override Dictionary<string, object> BuildAttributes()
    {
        var attributes = base.BuildAttributes();

        AppendToClassAttr(attributes, GetBaseClass());

        // Add placement class
        var placementClass = GetPlacementClass();
        if (placementClass != null)
            AppendToClassAttr(attributes, placementClass);

        // Add color class
        var colorClass = GetColorClass();
        if (colorClass != null)
            AppendToClassAttr(attributes, colorClass);


        // Add vertical specific class
        var verticalClass = GetVerticalClass();
        if (verticalClass != null)
            AppendToClassAttr(attributes, verticalClass);

        // Add expand class (horizontal only)
        var expandClass = GetExpandClass();
        if (expandClass != null)
            AppendToClassAttr(attributes, expandClass);

        // Add alignment class
        var alignmentClass = GetAlignmentClass();
        if (alignmentClass != null)
            AppendToClassAttr(attributes, alignmentClass);

        // Add collapse class (only for horizontal mode)
        if (Mode == BarMode.Horizontal)
        {
            var collapseClass = GetCollapseClass();
            if (collapseClass != null)
                AppendToClassAttr(attributes, collapseClass);
        }

        // For vertical sidebar mode, add specific styling
        if (Mode != BarMode.Horizontal)
        {
            AppendToClassAttr(attributes, "d-flex");
            AppendToClassAttr(attributes, "flex-column");
            AppendToClassAttr(attributes, "flex-shrink-0");
            AppendToClassAttr(attributes, "bg-light");
            AppendToClassAttr(attributes, "border-end");

            // Determine vertical sidebar state classes and width
            if (!SidebarVisible)
            {
                AppendToClassAttr(attributes, "sidebar-hidden");
                AppendStyleDeclAttr(attributes, "width: 0px");
            }
            else if (CollapseMode == BarCollapseMode.Small && _sidebarCollapsed)
            {
                AppendToClassAttr(attributes, "sidebar-collapsed");
                AppendStyleDeclAttr(attributes, "width: 60px");
            }
            else
            {
                AppendStyleDeclAttr(attributes, "width: 250px");
            }

            AppendStyleDeclAttr(attributes, "height: 100%");

            // Ensure the vertical nav participates in layout width, not flex-grow
            AppendStyleDeclAttr(attributes, "flex: 0 0 auto");

            // Provide a grouping id to act as Bootstrap collapse parent so only one opens at a time
            attributes["id"] = _collapseGroupId;
        }

        return attributes;
    }


    public async Task ToggleSidebar()
    {
        if (Mode == BarMode.Horizontal)
        {
            return;
        }

        if (CollapseMode == BarCollapseMode.Small)
        {
            // Toggle collapsed state for vertical bars when in Small collapse mode
            _sidebarCollapsed = !_sidebarCollapsed;

            // If we're collapsing the sidebar, also collapse all dropdowns
            if (_sidebarCollapsed)
            {
                _forceCollapseAll = true;
                // Reset the flag after a delay
                _ = Task.Run(async () =>
                {
                    await Task.Delay(100);
                    _forceCollapseAll = false;
                    await InvokeAsync(StateHasChanged);
                });
            }

            StateHasChanged();
            return;
        }

        // Fallback: toggle visibility (hide/show)
        await SidebarVisibleChanged.InvokeIfHasDelegate(!SidebarVisible);
    }

    private async Task HandleBarTogglerClick(MouseEventArgs args)
    {
        if (Mode != BarMode.Horizontal)
        {
            // Always collapse dropdowns first, then toggle sidebar after a brief delay
            await CollapseAllDropdowns();

            // Wait just enough for dropdowns to collapse, then toggle sidebar
            await Task.Delay(50);
            await ToggleSidebar();
        }
        else
        {
            // For horizontal bars, just collapse dropdowns
            await CollapseAllDropdowns();
        }
    }

    private async Task CollapseAllDropdowns()
    {
        // Trigger collapse of all dropdowns by updating state
        _forceCollapseAll = true;
        StateHasChanged();

        // Reset the flag after a brief delay to allow for re-opening
        await Task.Delay(100);
        _forceCollapseAll = false;
    }

    protected override void ApplyBackgroundColor(ref PooledStringBuilder sty, ref PooledStringBuilder cls)
    {
        if (BackgroundColor is { IsEmpty: false })
        {
            if (Transparent)
            {
                AppendClass(ref cls, "bg-transparent");
            }
            else
            {
                var isTheme = BackgroundColor.Value.TryGetBootstrapThemeToken(out var token);

                if (isTheme && token is not null)
                {
                    AppendClass(ref cls, $"bg-{token}");
                }
                else
                {
                    var result = BackgroundColor.ToString();
                    if (!result.HasContent()) return;

                    if (BackgroundColor.Value.IsCssStyle)
                        AppendStyleDecl(ref sty, $"background-color: {result}");
                    else
                        AppendClass(ref cls, $"bg-{result}");
                }
            }
        }
    }

}